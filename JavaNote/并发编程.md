

# 1.Lambda表达式

Lambda的本质: 作为函数式接口的实例

Lambda表达式只适用于函数式接口

**AIt+回车**直接将匿名内部类转换为Lambda

**为什么要使用Lambda表达式**

- 避免匿名内部类定义过多
- 可以让代码看起来更简洁
- 去掉没有意义的代码，只留下核心逻辑



**Lambda表达式基本结构**

```java
f -> { }
/** 
*f 是参数变量  非固定 f类型是系统根据上下文自动识别
*-> 是语法符号
*{ } 是语句块
**/
```



## 1.1Lambda表达式演变（推导）

**首先定义一个函数式接口**

```java
interface ILike{
    void lambda();
}
```

**对比实现类、静态内部类、局部内部类、匿名内部的实现及调用**

```java
//2.实现类
class Like implements ILike{
    @Override
    public void lambda() {
        System.out.println("I like lambda01");
    }
}
public class TestLambda {
    //3.静态内部类
    static class Like2 implements ILike {
        @Override
        public void lambda() {
            System.out.println("I like lambda02");
        }
    }
    public static void main(String[] args) {
        //调用实现类
        ILike like = new Like();
        like.lambda();
        
        //调用静态内部类
        like = new Like2();
        like.lambda();
        
        //4.局部内部类
        class Like3 implements ILike{
            @Override
            public void lambda() {
                System.out.println("I like Lambda03");
            }
        }
         //调用局部内部类
        like = new Like3();
        like.lambda();
        
        //5.匿名内部类,没有类的名称，必须借助接口或者父类
        like = new ILike() {
            @Override
            public void lambda() {
                System.out.println("I like Lambda04");
            }
        };
         //调用匿名内部类
        like.lambda();
    }
}
```

**显然匿名内部类更简洁，那么在匿名内部类的基础上进行简化**

```java
public class TestLambda2 {
    public static void main(String[] args) {
        //匿名内部类
        Ilove Love = new Ilove() {
            @Override
            public void love(int a) {
                System.out.println("i love you " + a);
            }
        };
        
        Love.love(1);
        
        //lambda简化
        Ilove ilove =(int a)->{System.out.println("i love you " + a);};
        ilove.love(2);
        
        //去掉参数类型
        ilove = (a)->{
            System.out.println("i love you " + a);
        };
        
        //去掉小括号
        ilove = a ->{System.out.println("i love you " + a);};
        
        //去掉大括号
        ilove = a -> System.out.println("i love you " + a);
    }
    
interface Ilove{
    void love(int a);
}
}
```

  ==**总结：**==

-    只能有一行时简化称为一行，否则{}包裹
-   必须是函数式接口（只有一个方法）
-    多个参数，参数类型一起操作，要么都保留，要么都删除



---





## 1.2 有类型参数与无类型参数		

**无类型参数实例**

```java
List<Student> students = new ArrayList<Student>();
students.add(new Student(111, "bbbb", "london"));
students.add(new Student(131, "aaaa", "nyc"));
students.add(new Student(121, "cccc", "jaipur"));

// 实现升序排序
Collections.sort(students, (student1, student2) -> {
  // 第一个参数的学号 vs 第二个参数的学号
  return student1.getRollNo() - student2.getRollNo();
});

//逆序 反减就行了
Collections.sort(students, (student1, student2) -> {
  return student2.getRollNo() - student1.getRollNo();
});

students.forEach(s -> System.out.println(s));
```

**注意：**

箭头（->）前表示参数变量，有 **多个参数** 的时候，必须使用小括号包裹：`()`

```java
(student1, student2) -> {}
```

箭头（->）前表示参数变量，**没有参数** 的时候，必须使用小括号：`()`

```java
() -> {}
```

箭头（->）后的执行语句 **只有一条** 时，可以不加大括号 `{}` 包裹

```java
s -> System.out.println(s);
```



---

**有类型参数实例**

```java
fruits.forEach((Fruit f) -> {
  System.out.println(f.getName());
});
```

**注意：**

使用有类型参数时，即使只有一个参数，也必须使用小括号：`()`包裹

```java
(Fruit f) -> {}
```









## 1.3引用外部变量

Lambda表达式`{}`内的执行语句,除了能引用参数变量外，还可以引用外部变量

```java
List<Fruit> fruits = Arrays.asList(......);
String message = "水果名称：";

fruits.forEach(f -> {
  System.out.println(message + f.getName());
});
```

**注意**

- 规范一：Lambda表达式引用的局部变量不允许被修改。即使修改代码写在表达式后面也不可以。甚至不可以在表达式内部修改
- 规范二：Lambda表达式的参数不能与局部变量同名。







## 1.4双冒号（::）操作符

​        Java 8 支持了一种新的语法：双冒号 “`::`”，这也是一种 Lambda 写法 ，是与 Lambda 表达式相关的一个重要特性。



只有一条执行语句的 *Lambda* 表达式：

```java
List<String> names = Arrays.asList("zhangSan", "LiSi", "WangWu");

names.forEach(n -> {
  System.out.println(n);
});
```

可以进一步简化为：

```java
names.forEach(System.out::println);
```

`::` 语法干脆省略了参数变量，所以读这段代码需要相互对照、并且自行脑补

这段代码的重点是使用 `::` 时，系统每次遍历取得的元素（`n`），会 **自动** 作为参数传递给 `System.out.println()` 方法打印输出

​	`System.out::println`等同于` n -> {System.out.println(n);}`

![img](https://typora-picgo-push.oss-cn-hangzhou.aliyuncs.com/img-for-typora/j5-1-5-1.svg)



---

**用法一：静态方法调用**

使用`System.out::println`代替` n -> {System.out.println(n);}`，简化代码

```java
```



---

**用法二：非静态方法调用**

`print()` 方法不再标识为 `static`,于是需要实例对象来调用

```java
//LambdaTest是类名
fruits.forEach(new LambdaTest()::print);
```

简写了

```java
LambdaTest lt = new LambdaTest();
fruits.forEach(lt::print);
```



---

**用法三：多参数**

升序案例：

```java
Collections.sort(students, (student1, student2) -> {
  // 第一个参数的学号 vs 第二个参数的学号
  return student1.getRollNo() - student2.getRollNo();
});
```

就碰到了多参数的情况。如果把比较的过程定义成一个方法：

```java
private static int compute(Student s1, Student s2) {
  ... ...
  ... ...
}
```

那么，排序过程就可以简写为：

```java
Collections.sort(students, SortTest::compute);
//SortTest是类名   compute是比较方法名
```

**注意**，系统会 自动获取上下文的参数，并按上下文定义的 **顺序** 传递给指定的方法。所谓 *顺序* 就是 *Lambda* 表达式 `()` 中的顺序。



---

**用法四：父类方法**

我们在《Java面向对象》学过，`super` 关键字的作用是在子类中引用父类的属性或者方法。那么同样，`::` 语法也可以用 `super` 关键字调用父类的**非静态方法**。

```java
import java.util.Arrays;
import java.util.List;

public class LambdaTest extends LambdaExample {
  public static void main(String[] args) {
    List<Fruit> fruits = Arrays.asList(
            new Fruit("香蕉"),
            new Fruit("苹果"),
            new Fruit("梨子"),
            new Fruit("西瓜"),
            new Fruit("荔枝")
    );

    LambdaTest at = new LambdaTest();
    at.print(fruits);
  }

  public void print(List<Fruit> fruits){
    fruits.forEach(super::print);
    }
}

class LambdaExample {
    public void print(Fruit f){
        System.out.println(f.getName());
    }
}
```









## 1.5Lambda操作多线程

原匿名内部类：

```java
new Thread(new Runnable(){
    @Override
    public void run() {
       System.out.println("run");
    }
}).start();
```

现Lambda表达式

```java
new Thread(()-> System.out.println("run")).start();
```







# 2.流 -Stream



- Java 8 的新特性：`Stream`（中文称之为：流）也是很常见且常用的，主要优点是提升开发效率，使代码更干净、简洁
- `Stream` 的主要作用是对集合（`Collection`）中的数据进行各种操作，增强了集合对象的功能。
- `Stream` 是一个接口（`interface`），当然也有多个实现类。但 Java 是面向接口编程的，我们暂时不用关心具体有哪些实现类，先学会使用 `Stream` `API`。(在接口中提供了操作数据的方法，通常我们叫作 `API`)



这里大家需要先了解两件事：

- 与我们在《Spring Web全栈》第二章第四节中学习的用于操作文件的 `InputStream` 完全不同，是完全不同的概念。不要混淆
- `Stream` 经常与 `Lambda` 表达式 配合使用

---

**流的方法作用**

```java
//创建操作
.stream() //将数据转化为流
    
    //中间操作
    .distinct() //去重
    .filter()  //过滤
    .
    
    //终结操作
    
    

```





## 2.1创建流与迭代流

**方式一：直接创建**

```java
import java.util.stream.Stream;

Stream<String> stream = Stream.of("苹果", "哈密瓜", "香蕉", "西瓜", "火龙果");
```

**方式二：由数组转化**

```java
String[] fruitArray = new String[] {"苹果", "哈密瓜", "香蕉", "西瓜", "火龙果"};
Stream<String> stream = Stream.of(fruitArray);
```

**方式三：由集合转化**

```java
List<String> fruits = new ArrayList<>();
fruits.add("苹果");
fruits.add("哈密瓜");
fruits.add("香蕉");
fruits.add("西瓜");
fruits.add("火龙果");
Stream<String> stream = fruits.stream();
```

**注意：** 无论是哪种方式创建，一定要清楚的知道：由于源数据（集合或数组）的数据是有序的，所以流中的元素也是有序排队的。



---

**迭代流**

我们知道集合类提供了 `forEach()` 方法可以遍历集合中的元素。很巧的是，`Stream` 提供的迭代方法也叫做 `forEach()`

```java
Stream<String> stream = Stream.of("苹果", "哈密瓜", "香蕉", "西瓜", "火龙果");
stream.forEach(System.out::println);
```

**注意**：为了能让系统自动识别 Lambda 表达式的参数类型，也必须使用泛型语法指定 `Stream` 中对象的类型。





## 2.2流数据过滤（条件判断）filter

数据过滤即剔除不需要的数据，如输出学生成绩高于80的学生，那么低于80的就是不需要的数据



**传统代码写法：**

```java
List<Pupil> pupils = new ArrayList<>();
// 这里假设小学生数据对象已经存入了

// 有资格的小学生集合
List<Pupil> qualified = new ArrayList<>();
for (Pupil pupil : pupils) {
    // 统计是否满足条件
    if (pupil.getAverageScore() >= 80) {
        qualified.add(pupil);
    }
}

// 打印符合条件的小学生姓名
for (Pupil pupil : qualified) {
    System.out.println(pupil.getName());
}
```

**java8新特性-流写法：**

```java
List<Pupil> pupils = new ArrayList<>();
// 这里假设小学生数据对象已经存入了

pupils.stream()  //转化为流
    .filter(pupil -> pupil.getAverageScore() >= 80)
    .forEach(pupil -> {System.out.println(pupil.getName());});
```

**filter() 方法** : 从方法名我们可以理解其功能：对流中的数据对象进行过滤。

![img](https://typora-picgo-push.oss-cn-hangzhou.aliyuncs.com/img-for-typora/j5-2-3-2.svg)

方法参数是一个 Lambda 表达式，箭头后面是条件语句，判断数据需要 **符合** 的条件。

也就是说，使用 Lambda 表达式告诉过滤器，需要那些 **符合** 条件的数据（把不符合条件的数据过滤掉）。

> 注意：这里的 Lambda 表达式略有不同。
>
> 箭头后的过滤条件语句（非可执行的语句）。传统代码中，条件语句写在 () 中的，所以新特性条件语句可以用 () 而不能用 {} 哦
>
> 等同于 pupil -> ((pupil.getAverageScore() >= 80) && (pupil.getViolationCount() < 1))







## 2.3流的设计思想



数据流的操作过程，可以看做一个管道，管道由多个节点组成，每个节点完成一个操作。

数据流输入这个管道，按照 **顺序** 经过各个节点。上节课的案例中，最后完成输出到 console。

![img](https://typora-picgo-push.oss-cn-hangzhou.aliyuncs.com/img-for-typora/j5-2-4-1.svg)

> 案例中，`.filter().forEach()` 组成了一个管道，每个方法都是管道的一个节点。方法调用的顺序构成了管道的节点顺序。



对比普通 Java 代码，`Stream` 的显著特点是：编程的重点，不再是对象的运用，而是数据的计算。

如果使用普通的 Java 代码，重点是使用对象完成各种各样的逻辑，加上语法代码也比较多，导致整个代码比较繁复。

使用了 `Stream API`，系统会自动完成很多操作，加上大幅度简化了语法，开发者的注意力重点就变为捋清楚数据计算的步骤，不用太关心变量类型、变量赋值、对象转换等。编程的重点更加清晰。

Stream 的这种变化，特征是：函数式风格。即弱化了面向对象的严格、完整的语法，重心变为通过函数完成数据计算。

> 记住 函数式 这个词

![img](https://typora-picgo-push.oss-cn-hangzhou.aliyuncs.com/img-for-typora/j5-2-8-1.svg)

大家在练习过程中，务必对比代码，不仅要学会运用 `Stream API`，更要思考和理解 `Stream` 的特点。







## 2.4流数据映射(修改数据) map

`map()` 方法通常称作**映射**，其作用就是用新的元素替换掉流中原来**相同位置**的元素。相当于每个对象都经历一次转换。

`map()` 方法可以改变流中的数据类型

`map()` 方法的参数是一个 *Lambda* 表达式，在语句块中对流中的每个数据对象进行计算、处理，最后用 `return` 语句返回的对象，就是转换后的对象。

![img](https://typora-picgo-push.oss-cn-hangzhou.aliyuncs.com/img-for-typora/j5-2-5-1.svg)

**优点**

- 映射后的对象类型，可以与流中原始的对象类型不一致。
- 在流中，可以用字符串替换原来的整数。这就极大的提供了***灵活性***、***扩展性***，让流的后继操作可以更方便。



**代码实例一 -计算一组数字中每个数字的平方数**

```java
List<Integer> numbers = Arrays.asList(3, 2, 2, 7, 63, 2, 3, 5);

numbers.stream()
    .map(num -> {
        return num * num;
    })
    .forEach(System.out::println);
```

**特例写法**

少数情况下，如果替换语句简单、系统能自动识别需要返回的值，代码可以简写为：

```java
.map(num -> num * num)  //不建议
```



**代码实例二 -多条件需要判断时**

```java
 .map(pupil -> {
              if (pupil.getAverageScore() > 85) {
                  pupil.setMessage(pupil.getName() + "同学您的成绩优秀，恭喜入围");
              } else {
                  pupil.setMessage(pupil.getName() + "同学您的成绩优良，恭喜入围");
              }
              return pupil;
          })
```





---







## 2.5流数据排序 sorted



**Lambda表达式排序**

```java
// 实现升序排序
Collections.sort(students, (student1, student2) -> {
  // 第一个参数的学号 > 第二个参数的学号
  return student1.getRollNo() - student2.getRollNo();
});
```

**流操作排序**

```java
students.stream()
    // 实现升序排序
    .sorted((student1, student2) -> {
        return student1.getRollNo() - student2.getRollNo();
    })
    .forEach(System.out::println);
```

`sorted()` 顾名思义，就是完成排序的方法。把排序规则写成一个 Lambda 表达式传给此方法即可。

> 核心的排序规则 Lambda 表达式是一样的。

**参数顺序**    无论是 *Lambda 表达式* 写法，还是 *Stream API* 写法，参数 `(student1, student2)` 中的 *student1* 指代后一个元素，*student2* 指代前一个元素。不要被变量名迷惑了哦



**特例写法**   少数情况下，如果排序计算语句简单、系统能自动识别需要返回的值，代码可以简写为：

```java
.sorted((student1, student2) -> student1.getRollNo() - student2.getRollNo())
```









## 2.6流数据摘取 limit



**流操作完成一组数字中取最大的前三个数**

```java
List<Integer> numbers = Arrays.asList(3, 2, 2, 7, 63, 2, 3, 5);

numbers.stream()
    .sorted((n1, n2) -> n2 - n1)
    .limit(3)
    .forEach(System.out::println);
```

`limit()` 方法的作用是返回流的 **前** `n` 个元素，当然 `n` 不能为负数。 不是摘取任意位置哦，只能是流开头的.





## 2.7流合并（计算）reduce



**流操作整数完成一组数据的求和**

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

int sum = numbers.stream()
    .reduce((a, b) -> a + b)
    .get();
System.out.println("1-10求和 : " + sum);
```

- `reduce()` 方法的作用，是合并了所有的元素，***终止*** 计算出一个结果。注意这里终止的意思，就是流已经到达终点结束了，不能再继续流动了。
- `reduce()` 方法的返回值是一个比较复杂的对象，需要调用 `get()` 方法返回最终的整数值。同理，`get()` 方法返回值的类型，也是系统自动根据流中元素类型推定的。

`reduce()` 方法的参数就稍微有点**复杂**了（重点理解）：

- `a` 在第一次执行计算语句 `a + b` 时，指代流的第一个元素；然后充当缓存作用以存放本次计算结果。此后执行计算语句时，`a` 的值就是上一次的计算结果并继续充当缓存存放本次计算结果。
- `b` 参数第一次执行计算语句时指代流的第二个元素。此后依次指代流的每个元素。



**实例： 计算平均分**

```java
        List<Student> students = new ArrayList<>();
        students.add(new Student("赵祯", 92));
        students.add(new Student("曹丹姝", 60));
  
        int classScore = students.stream()
            .map(s -> {  
                return s.getMidtermScore();  //先用map改变流中数据类型
            })
            .reduce((s1, s2) -> s1 + s2)  
            .get();

        System.out.println("三年二班期中考试平均分：" + (int)(classScore/students.size()));
```



---

​	

**流操作对象完成平均分计算**

```java
  List<Student> students = new ArrayList<>();
        students.add(new Student("赵祯", 92, 92));
        students.add(new Student("曹丹姝", 60, 75));

        Student reduce = students.stream()
          .reduce(new Student(" ", 0, 0),//如果不new一个新对象，会出现bug，第一个对象会充当了缓存角色，正确性被破坏
                 (a, b) -> {
                        a.setMidtermScore(a.getMidtermScore() + b.getMidtermScore());
                        a.setLastScore(a.getLastScore() + b.getLastScore());
                        return a;});
	System.out.println("三年二班期中考试平均分：" + (reduce.getMidtermScore()/students.size()));           		System.out.println("三年二班期末考试平均分：" + (reduce.getLastScore()/students.size()));	

```

`reduce()` 方法的参数变为了两个：

- 第一个参数，是作为*缓存角色*的对象
- 第二个参数，是Lambda表达式，完成计算，格式是一样的。
  - 那么 `a` 变量不再指代流中的第一个元素了，专门指代*缓存角色*的对象，即方法第一个参数对象。
  - `b` 变量依次指代流的每个元素，包括第一个元素。
  - `a`、`b` 职责非常清晰了。

对照下图理解 `a`、`b` 参数的功能变化：

![img](https://typora-picgo-push.oss-cn-hangzhou.aliyuncs.com/img-for-typora/j5-3-2-1.svg)

`reduce()` 方法的返回值同样发送了变化，**返回**作为*缓存角色*的对象，即第一个参数。

> **不用**再调用一次 `get()`





## 2.8流收集 collect



`forEach()` 方法和 `reduce()` 方法都是流的终点哦。本节再来学习一种属于终点的流操作：收集。

在实际工作中，整体功能如果比较复杂的话，使用流对集合进行计算后，可能并不想输出和合并，而是把结果元素放在一个新的集合中，待进一步使用。例如，新的集合可以传递给 Thymeleaf 模板等等。

**实例：找到一组数字最大的三个数字放入新集合，用-组成字符串输出**

```java
List<Integer> numbers = Arrays.asList(3, 2, 2, 7, 63, 2, 3, 5);

List<String> numResult = numbers.stream()
    .sorted((n1, n2) -> n2 - n1)   
    .limit(3)
    .map(a -> "" + a)
    .collect(Collectors.toList());

String string = String.join("-", numResult);
System.out.println("字符串是: " + string);
```

- `collect()` 方法的作用就是收集元素。

- `Collectors.toList()` 是一个静态方法，作为参数告诉 `collect()` 方法存入一个 `List` 集合。

> ​		  所以 `collect()` 方法的返回值类型就是 `List`。
>
> ​		 `java.util.stream.Collectors` 是流工具包中提供的收集器。

- 为了能够把最终结果转换为字符串打印，调用了 `map()` 方法把流中原来的整数映射为字符串（`"" + a`），所以 `collect()` 方法的返回值类型就是 `List<String>`，而不是 `List<Integer>`。







## 2.9并行流 parallelStream

串行：每个节点依次执行，下一个节点必须等上一个节点执行完毕。串行工作模式无法发挥多核cpu的优势

并行：利用多线程，变成同时执行



使用并行流的代码就是不再调用`stream()` 方法，改为调用 `parallelStream()` 方法即可。其它的计算方法是一样的。

`parallelStream()` 以并行的方式执行任务，同时也支持流的收集、合并等计算。结合下图理解与串行运算的不同：

![img](https://typora-picgo-push.oss-cn-hangzhou.aliyuncs.com/img-for-typora/j5-3-4-1.svg)



**注意：有如下几点不适合并行计算：**

流中的每个数据元素之间，有逻辑依赖关系的时候，不适合使用并行计算。

因为并行计算使用了多线程，每个线程独立输出数字，而线程的输出时机，是由 *CPU* 动态决定的，无法确定。

所以，逻辑上要求数字必须按书写的前后顺序（数字之间有逻辑顺序）输出时，就不能使用并行计算。



---





# 3.设计模式



## 3.1单例模式

***单例*** 设计模式：保证只有一个实例对象的方式

**保证一个类仅有一个实例 --方法：把构造函数设为私有。当把构造函数设为私有后，除了类自己，其他任何类都不能实例化其对象**

```java
public class ClassMaster {
  private String id;
  // 班主任名称
  private String name;

  // 唯一实例 ClassMaster自己实例化自己
  private static ClassMaster instance = new ClassMaster();

  private ClassMaster() {
  }
}
```

`ClassMaster` 类中定义一个 `ClassMaster` 类型的变量，赋值为 `new` 出来的自己的实例。

> 要注意：**必须**使用 `static` 修饰符，否则会造成死递归的严重的错误。

也就是说，不允许其他类实例化 `ClassMaster`（私有化构造方法）、只有自己能实例化一个唯一的自己（private static），所以可以保证 `ClassMaster` 的实例是全局唯一的。



**类`new` 出一个实例的目的，是要给其他类使用的。所以还需要增加一个方法，允许其他类访问这个单例的实例。**

```java
public class ClassMaster {
  private String id;
  // 班主任名称
  private String name;

  // 唯一实例 （私有的静态实例）
  private static ClassMaster instance = new ClassMaster();

    //（私有的构造方法）
  private ClassMaster() {
  }

  // 外部类可以通过这个方法访问唯一的实例   （公共静态访问方法）
  public static ClassMaster getInstance() {
    return instance;
  }
    
    //方法
    public void print(){   
         System.out.println("  ");
    }
}
```



---

**Spring中的单例模式**

任何**自动**注入实例对象，默认只有一个实例对象，是单例的。例如：可能多个 `Service` 和 `Control` 等都需要用到用户服务，那么这些类中都会定义：

```java
@Autowired
private UsersService usersService;
```

**Spring** 会保证只生成一个 `UsersServiceImpl` 实例，注入到多个 `Service` 或 `Control` 中，不会为每个 `Service` 或 `Control` 分别 `new` 出多个 `UsersServiceImpl` 实现类的实例。

虽然我们写 `Service` 服务的时候没有像写 `ClassMaster` 代码一样使用私有的构造方法，但 **Spring** 也应用了 ***单例*** 的 ***思想*** 来减少不必要的消耗。

---

**总结**

单例模式不仅仅一段代码，它更是一种思想。

我们可以编码来实现；Spring 作为框架在管理各个 *bean* 过程中，也用到、实现了这个思想。

虽然具体实现编码有不同，但大家都用这种思想解决了一类问题。









## 3.2简单工厂模式（静态）

学习视频：https://www.bilibili.com/video/BV1mc411h719?p=3&vd_source=2f0cee9ab04c26aacbb64624794caaac

所谓工厂，就是生产物品的。程序中的工厂，就是生产实例对象的。

**实现简工厂的两个步骤：**

- 从具体的产品类抽象出接口。工厂应该生产一种产品，不应该生产某一个产品
- 把生产实例的过程，收拢到工厂类中实现



**实例：简单工厂生产对应的不同水果**

```java
public class FruitFactory {
    public static Fruit getFruit(Customer customer) {
        Fruit fruit = null;
        if ("sweet".equals(customer.getFlavor())) {
            fruit = new Watermelon();
        } else if ("acid".equals(customer.getFlavor())) {
            fruit = new Lemon();
        } else if ("smelly".equals(customer.getFlavor())) {
            fruit = new Durian();
        }
        return fruit;
    }
}
```

工厂仍然要实现功能，完成“根据不同条件创建不同对象”需求。

工厂的主要优点在于 ***职责明确*** 。餐馆、甜品店等需要水果的地方只需要告诉工厂顾客的口味，获得工厂生产的水果，但不需要知道具体是什么水果。餐馆和甜品店的责任是上菜，生产的责任交给工厂。

---

**命名**

一般来说，工厂类命名为 `XXXXFactory`，以 `Factory` 作为后缀可以提高辨识度，易于理解这个类的作用。

工厂类中的方法，依据实际情况而定，并没有特别的约定。方法名、输入参数、返回值，都是要根据实际需求确定的。

> 方法名是自由命名的。大家如果没有特别好的创意，建议选用 `get`、`create`、`make` 或 `build` 作为前缀

---

**重点**

理解简单工厂设计模式，重点还是要理解这种思想，以及适用的场景。

使用简单工厂完成功能开发时，重点就是要明确 ***什么条件*** 下创建 ***什么实例对象*** 的需求逻辑。







## 3.3抽象工厂模式



简单工厂主要是把多个产品抽象，使用一个工厂创建；

抽象工厂的主要作用是把多个工厂进一步抽象；

---



<img src="https://typora-picgo-push.oss-cn-hangzhou.aliyuncs.com/img-for-typora/j5-4-4-1.svg" alt="j5-4-4-1.svg" style="zoom:67%;" />

**工厂接口**

工厂接口（`SnacksFactory`）即规定工厂应该提供什么样的产品，所以包含了所有工厂的方法：

```java
public interface SnacksFactory {
    // 取得水果
    public Fruit getFruit(Customer customer);
    // 取得饮料
    public Drink getDrink(Customer customer);
}
```

但水果工厂不提供饮料，可实现工厂接口后又必须实现`getDrink()` 方法，这时候直接返回 `null` 即可。

```java
public class FruitFactory implements SnacksFactory {
    public Drink getDrink(Customer customer) {
        return null;
    }
}
```



---

**工厂的工厂**

`SnacksFactoryBuilder` 称之为 生产工厂的工厂 ，工厂用来生成产品实例，`SnacksFactoryBuilder` 用来生成工厂实例。

```java
public class SnacksFactoryBuilder {   
    public SnacksFactory buildFactory(String choice) {  //注意：非静态
        if (choice.equalsIgnoreCase("fruit")) {
            return new FruitFactory();
        } else if (choice.equalsIgnoreCase("drink")) {
            return new DrinkFactory();
        }
        return null;
    }
}
```

从简单工厂到抽象工厂，完成了对产品的抽象和对工厂的抽象。

**注意：**

`SnacksFactoryBuilder` 的 `buildFactory()` 方法并不是 `static` 的。

因为复杂场景下尽量不要使用类（static）方法，实例方法可以被继承，扩展性较好，应该优先使用实例方法。

> 《Java语言入门》课程中把 static 方法称之为静态方法，没有 static 的方法叫对象方法。实际上，**静态方法** = **类方法**，**对象方法** = **实例方法**，只是叫法不同罢了。

---

抽象工厂实例的UML图：

![image-20230508210337229](https://typora-picgo-push.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20230508210337229.png)







## 3.4 工厂模式结合Spring工程

工厂模式中不提倡定义`static`方法



在使用Spring框架的时候，可以为`SnacksFactoryBuilder`加上`@Component`注解，可以让框架管理实例

```java
//工厂生产者
@Component
public class SnacksFactoryBuilder {  
    public SnacksFactory buildFactory(String choice) {

    }
}
```

任何需要使用工厂的地方，只需要使用`@Autowired`注解让框架自动注入实例

```java
@Service
public class XxxxxServiceImpl implements XxxxxService {
    @Autowired
    private SnacksFactoryBuilder snacksFactoryBuilder;
}
```

这样可以让工厂模式的代码与Spring互为一体，扩展性更好、更易于维护。







## 3.5观察者模式



观察者模式的核心是要知道观察什么，什么对象发生了什么变化需要通知。

```java
import java.util.Observable;
public class xxxx extends Observable {
    
}
```

Observable类是java提供的，继承了就是表示是核心的、需要被观察的类。  xxx是被观察者

---

**定义 JDK 实现的观察主体**

```java
public class WeatherData extends Observable {
    // 城市
    private String cityName;
    // 时间
    private String time;
    // 温度
    private String temp;

    // 城市固定了就不变了
    public WeatherData(String cityName) {
        this.cityName = cityName;
    }

    // 打印天气信息
    public String toString() {
        return cityName + "，" + LocalDate.now().toString() + " " + time + "，气温：" + temp + "摄氏度。";
    }
//get手动生成 
    
    
    /**
     * 修改   （一个城市的气温在某个时刻发生了变化）
     */
    public void changeTemp(String time, String temp) {
        if(time == null || temp == null) {
            // 输入数据为空是有问题的，不处理
            return;
        }

        // 与原数据不同，说明发生了变化
        if(!time.equals(this.time) || !temp.equals(this.temp)) {
            // 标记变化
            super.setChanged();
            this.time = time;
            this.temp = temp;
            // 发出通知，参数是额外的信息
            super.notifyObservers("温度变化已通知");
        }
    }
}
```

- 在 `changeTemp()` 中，如果天气数据与原来不同，则会标记变化并发出通知。
- 父类 `Observable` 提供的方法 `setChanged()` 就是标记被观察者对象发送了变化。
- 父类 `Observable` 提供的方法 `notifyObservers()` 就是发出通知；如果需要发送额外（不在被观察者对象里的）的信息，在参数中传入信息对象，可以是 **任意对象** ，需要自己根据具体的需求场景而定。如果不想发送额外信息，可以写为super.notifyObservers(null)



---

**观察者**     观察者需要实现 `Observer` 接口，也是 Java 提供的，实现此接口表示作为观察者。

```java
public class WeatherObserver implements Observer {
    private String name;

    @Override
    public void update(Observable o, Object arg) {
        System.out.print(this.name + "观察到天气变化为：");
        System.out.print(o.toString());
        System.out.println(" " + arg);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
    
}
```

作为观察者，实现 `Observer` 接口后，要自己实现 `update()` 方法，方法签名是接口中定义好的，属于固定写法。

- 第一个参数就是被观察者对象，被观察者对象都需要继承自 Observable
- 第二个参数就是额外的信息，具体说就是调用 `super.notifyObservers()` 是传入的参数对象；传入什么对象，arg 的值就是什么对象

如果不想发送额外信息，写为 super.notifyObservers(null) ，那么这里 arg 值就是 null ，注意避免空指针异常哦。

`update()` 方法的作用就是接收通知。实际上，系统在 `super.notifyObservers()` 发出通知后，及调用所有观察者的 `update()` 方法，完成通知的过程。



---

**调用**

```java
public class WeatherTest {
    public static void main(String[] args) {
        // 在天气变化后发邮件的观察者
        WeatherObserver w1 = new WeatherObserver();
        w1.setName("天气邮件观察者");

        // 在天气变化后发短信的观察者
        WeatherObserver w2 = new WeatherObserver();
        w2.setName("天气短信观察者");

        // 城市天气数据
        WeatherData weatherData = new WeatherData("余杭");
        // 添加观察者
        weatherData.addObserver(w1);
        weatherData.addObserver(w2);

        // 气温变化
        weatherData.changeTemp("11:08", "32.8");
        // 气温变化
        weatherData.changeTemp("14:46", "29.3");
    }
}
```

观察者可以有多个。观察者对象与被观察者对象谁先 `new` 出来都可以，但是必须先调用 `addObserver()` 方法把观察者对象实例添加到被观察者（天气数据）实例中，然后再调用自定义的 `changeTemp()` 方法变更天气，才能触发自动通知。



---

UML图：

<img src="https://typora-picgo-push.oss-cn-hangzhou.aliyuncs.com/img-for-typora/20230510145524.png" style="zoom: 80%;" />



---













# 1.进程与线程

![image-20230426191021252](https://typora-picgo-push.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20230426191021252.png)





# 2.线程创建

**线程创建三种方式：**

- Thread class         --->继承 Thread 类
- Runnable 接口     ---->实现 Runnable 接口
- Callable 接口        ---->实现 Callable 接口

---

**创建线程方式一：继承Thread类，重写run()方法，调用start开启线程**

- 子类继承Thread类具备多线程能力
- 启动线程：子类对象.start()
- 不建议使用：避免OOP单继承局限性

```java
//总结，线程开启不一定立即执行，由cpu调度执行
public class Demo1 extends Thread{
    @Override
    public void run() {
        //run 方法线程体
        for (int i = 0; i < 20; i++) {
            System.out.println("我在看线程代码！");
        }
    }
    
    public static void main(String[] args) {
        //main线程，主线程
        //创建一个线程对象
        Demo1 testThread1 = new Demo1();
        //调用start（）方法主线程和创建的线程交替进行
        testThread1.start();
        //调用run（）方法会按顺序执行线程
        //testThread1.run();
        for (int i = 0; i < 2000; i++) {
            System.out.println("我在学习多线程！");
        }
    }
}
```

**创建线程方式二：实现Runnable接口，重写run方法**

- 实现接口Runnable具有多线程能力
- 启动线程：传入目标对象+Thread对象.start()
- 推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用

```java
//执行线程需要丢入runnable接口实现类，调用start方法
public class Demo3 implements Runnable{
    @Override
    public void run() {
    //run 方法线程体
        for (int i = 0; i < 200; i++) {
            System.out.println("我在看线程代码！");
        }
    }
    
    public static void main(String[] args) {
        //main线程，主线程
        //创建一个runnable接口的实现类对象
        Demo3 testThread3 = new Demo3();
        //创建线程对象，通过线程对象来开启我们的线程，代理
        new Thread(testThread3).start();
        for (int i = 0; i < 1000; i++) {
            System.out.println("我在学习多线程！");
        }
    }
}
```

**创建线程方式三：实现Callable接口，重写run方法**

Runnable接口的run方法是没有返回值的，但有时候我们希望某个任务在执行完毕后返回一个结果，那么可以实现Callable接口。

Callable优势：

- 可以定义返回值
- 可以抛出异常

Thread类不接受Callable对象，需要使用FutureTask类来执行Callable任务

```java
public class Demo4 {
    public static void main(String[] args) {
        Callable1 callable1=new Callable1();
        //创建FutureTask实例执行Callable
        FutureTask futureTask=new FutureTask(callable1);
        //启动Callable
        futureTask.run();

        try {
            //获取线程执行结果
            String str= (String) futureTask.get();
            System.out.println(str);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } catch (ExecutionException e) {
            throw new RuntimeException(e);
        }
    }
}

class Callable1 implements Callable{
    @Override
    public Object call() throws Exception {

        return "hehe";
    }
}
```

> 注意：run方法只是一个普通方法不会启动线程，start() 方法调用的run才是线程 。
>
> start方法源码：

```java
cat.start();

//(1) 其调用的是 start0 方法
public synchronized void start(){
  start0();  
}

//(2) start0是本地方法，最底层了，无法再追进  是JVM调度的，底层由C/C++实
private native void start0();

//可以理解为真正实现多线程效果的是start0 调用的run方法
```





# 3.线程状态

![image-20230512120727996](https://typora-picgo-push.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20230512120727996.png)

官方文档：

**六大状态**：创建、可运行（可运行分就绪和运行）、阻塞、等待、超时等待、死亡

![image-20230613162606539](https://typora-picgo-push.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20230613162606539.png)



```java
NEW      //创建
RUNNABLE //运行
BLOCKED  //阻塞
WAITING  //等待(一直等)
TIMED_WAITING //超时等待（等一段时间）
TERMINATED  // 终止
```







## 3.1线程停止

- 不推荐使用JDK提供的stop()、destroy()方法。【已废弃】
- 推荐线程自己停止下来
- 建议使用一个标志位进行终止变量,当flag=false，则终止线程运行。

```java
public class Demo10 implements Runnable{
    //1.设置一个标志位
    private  boolean flag = true;
    @Override
    public void run() {
        int i = 0;
        while (flag){
            System.out.println("run...Thread"+i++);
        }
    }
    //2.设置一个公开的方法停止进程，转换标志位
    public void stop(){
        this.flag=false;
    }
    //主方法调用
    public static void main(String[] args) {
        Demo10 testStop = new Demo10();
        new Thread(testStop).start();
        for (int i = 0; i < 1000; i++) {
            System.out.println("main"+i);
            if (i==900){
                //调用stop方法切换标志位，让线程停止
                testStop.stop();
                System.out.println("线程该停止了");
            }
        }
    }
}
```





## 3.2线程休眠 sleep

- sleep(时间)指定当前线程阻塞的毫秒数
- sleep存在异常InterruptedException
- sleep时间达到后线程进入就绪状态
- sleep可以模拟网络延时，倒计时等
- 每一个对象都有一个锁，sleep不会释放锁
- **调用Interrupt方法可以中断休眠，提前执行**

```java
//模拟倒计时
Date startTime = new Date(System.currentTimeMillis());//获取系统时间
        try {
           Thread.sleep(1000);
           System.out.println(new SimpleDateFormat("HH:mm:ss").format(startTime));
           startTime = new Date(System.currentTimeMillis());//更新当前时间
        } catch (InterruptedException e) {
           e.printStackTrace();
        }
```





## 3.3线程礼让 yield

- 礼让线程，让当前正在执行的线程暂停，但不阻塞
- 将线程从运行状态转为就绪状态
- 让cpu重新调度，礼让不一定成功!看CPU心情

```java
public class Demo12 {
    public static void main(String[] args) {
        MyYield myYield = new MyYield();
        new Thread(myYield,"小明").start();
        new Thread(myYield,"小亮").start();
    }
}
class MyYield implements Runnable{
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+"线程开始");
        Thread.yield();  //礼让
        System.out.println(Thread.currentThread().getName()+"线程结束");
    }
}
//Thread.currentThread().getName() 获 取当前正在执行的线程的名字
```





## 3.4线程强制执行 join

join就是阻塞当前线程，等join的线程执行完后，进入就绪状态

```java
//测试join方法（插队)
public class Demo13 implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i < 1000; i++) {
            System.out.println("线程vip来了"+i);
        }
    }
    
    
    public static void main(String[] args) throws InterruptedException{
        Demo13 testJoin = new Demo13();
        Thread thread = new Thread(testJoin);
        thread.start();
        for (int i = 0; i < 500; i++) {
            if (i==200){
                thread.join();//插队
            }
            System.out.println("main"+i);
        }
    }
}
```





## 3.5线程唤醒与等待

在 Java 当中，实现线程之间进行通讯和配合执行的功能有三个方法：

- wait() / wait(long timeout)：让线程进入等待状态。
- notify()：唤醒当前对象上一个休眠的线程。
- notifyAll()：唤醒当前对象上的所有线程。

---

- wait()：释放锁，线程进入休眠状态等待唤醒
  例： `object.wait();` 释放object对象的锁并且本线程进入休眠状态，等待其他获得object对象的锁的线程执行notify()/notifyAll()方法进行唤醒。
- wait(long timeout)：指定等待的毫秒数
  如果一个线程调用共享对象的该方法挂起后，没有在指定的timeout ms 内被其他线程调用该共享变量的notify()或者 notifyAll() 方法唤醒，那么该函数还是会因为超时而返回。如果将 timeout置为0则和wait方法效果一样，因为在 wait()方法内部就是调用了 wait(0)。

---

```java
public class Demo4 {
    public static void main(String[] args) {
        Object o = new Object();

        //等待线程
        Runnable runnableWait = new Runnable() {
            @Override
            public void run() {
                while (true) {
                    synchronized (o) {
                        try {
                            System.out.println(Thread.currentThread().getName() + "进入等待....");
                            o.wait();
                            System.out.println(Thread.currentThread().getName() + "已获取唤醒通知");
                            System.out.println(Thread.currentThread().getName() + "已执行一次");
                        } catch (InterruptedException e) {
                            throw new RuntimeException(e);
                        }
                    }}}
        };

        //唤醒线程
        Runnable runnableNotify = new Runnable() {
            @Override
            public void run() {
                synchronized (o) {
                    System.out.println(Thread.currentThread().getName() + "执行唤醒");
                    o.notify();
                    System.out.println(Thread.currentThread().getName() + "已执行唤醒");
                }
            }
        };
        //启动线程
        new Thread(runnableWait).start();
        new Thread(runnableNotify).start();
    }
}

```







# 4.线程的优先级

- Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行。
- 线程的优先级用数字表示，范围从1~10.
- Thread.MIN_PRIORITY = 1;
- Thread.MAX_PRIORITY = 10;
- Thread.NORM_PRIORITY = 5;
- 使用以下方式改变或获取优先级
- getPriority()/.setPriority(int xxx)

```java
public class demo15 {
    public static void main(String[] args) {
        MyPriority myPriority = new MyPriority();
        Thread t1 = new Thread(myPriority);
        Thread t2 = new Thread(myPriority);
        Thread t3 = new Thread(myPriority);
       
        //设置优先级
        t1.setPriority(2);
        t2.setPriority(NORM_PRIORITY);
        t3.setPriority(4);

        t1.start();
        t2.start();
        t3.start();
    }
}

class MyPriority implements Runnable{
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+"-->"+Thread.currentThread().getPriority());
    }
}
```





# 5.守护线程

守护线程是为所有非守护线程提供服务的线程，

如果想主线程结束后，子线程也结束，只需要将子线程设置为守护线程 setDaemon(true);

常见的守护线程：垃圾回收机制

---



- 线程分为用户线程和守护线程
- 虚拟机必须确保用户线程执行完毕
- 虚拟机不用等待守护线程执行完毕
- 如,后台记录操作日志,监控内存,垃圾回收等待

```java
public class Demo16 {
    public static void main(String[] args) {
        God god = new God();
        You2 you2 = new You2();
        Thread thread =new Thread(god);
        thread.setDaemon(true);//默认是false表示是用户线程，正常的线程都是用户线程
        thread.start();//上帝守护线程启动
        new Thread(you2).start();
    }
}

class God implements Runnable{
    @Override
    public void run() {
        while (true){
            System.out.println("上帝保佑着你！");
        }
    }
}

class You2 implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i < 36500; i++) {
            System.out.println("你开心的活着！");
        }
        System.out.println("Goodbye World!");
    }
}
```



# 6.线程同步机制

**线程同步**

- 并发:同一个对象被多个线程同时操作

  处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象。这时候我们就需要线程同步。线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程使用完毕，下一个线程再使用

由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确   性,在访问时加入**锁机制synchronized** ，当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可.存以下问题:

- 一个线程持有锁会导致其他所有需要此锁的线程挂起；
- 在多线程竞争下，加锁。释放锁会导致比较多的上下文切换和调度延时，引起性能问题；
- 如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能问题。

---



## 6.1 线程安全

多个线程操作同一个资源的时候，发生了冲突的现象，就叫做线程不安全

**如何保证线程安全：**

- **Synchronize**关键字：保证只有一个线程拿到锁，进入同步代码块操作共享资源，临界区内的代码对外是不可分割的，不会被线程切换打断，保证了原子性 （**本质就是排队，先进先出**）
- **volatile**关键字：被volatile关键字修饰的变量，一旦被线程修改，其他线程锁保持的该变量的缓存就会失效，需要从内存中获取最新值，也叫做MESI缓存一致性
- **atomic**原子类：一种乐观锁，用atomic原子类代替基本数据类型，无论原子更新哪种类型，都要遵循比较和替换原则，即要比较的更新值是否等于期望值，是则更新，不是则失败，保证了原子性

![image-20230513105337436](https://typora-picgo-push.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20230513105337436.png)

**线程不安全案例**

```java
//不安全的买票
//线程不安全，有小于等于0的数出现，
public class Demo17 {
    public static void main(String[] args) {
        BuyTicket buyTicket = new BuyTicket();
        new Thread(buyTicket,"眉笔的我").start();
        new Thread(buyTicket,"欧皇的你").start();
        new Thread(buyTicket,"可恶的黄牛党").start();
    }
}

class BuyTicket implements Runnable{
    private int ticketNums=10;//票数
    boolean flag = true;//外部停止方式
    @Override
    public void run() {
        while (flag){
            try {
                buy();//买票
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    
    private void buy() throws InterruptedException {
        if (ticketNums<=0){//判断是否有票
            flag=false;
            return;
        }
        Thread.sleep(100);//模拟延迟
        System.out.println(Thread.currentThread().getName()+"买到了第"+ticketNums--+"张票");
    }
   
}
```

以上代码会使得取到的票号有小于等于0的数出现。

解及该问题有三种办法：

- 同步块
- 同步方法
- 同步锁



---







## 6.2 **同步方法**与**同步块 **

**同步方法**

- 由于我们可以通过private关键字来保证数据对象只能被方法访问,所以我们只需要针对方法提出一套机制，这套机制就是synchronized关键字，它包括两种用法∶synchronized方法和synchronized块.
- synchronized方法控制对“对象”的访问﹐每个对象对应一把锁,每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行﹐就独占该锁，直到该方法返回才释放锁﹐后面被阻塞的线程才能获得这个锁,继续执行
- 缺陷:若将一个大的方法申明为synchronized将会影响效率

---

- 同步方法

```java
//不安全的买票案例修改
public class Demo17 {
    public static void main(String[] args) {
        BuyTicket buyTicket = new BuyTicket();
        new Thread(buyTicket, "眉笔的我").start();
        new Thread(buyTicket, "欧皇的你").start();
        new Thread(buyTicket, "可恶的黄牛党").start();
    }
}


class BuyTicket implements Runnable {
    private int ticketNums = 10;//票数
    boolean flag = true;//外部停止方式
    @Override
    public void run() {
        while (flag) {
            try {
                Thread.sleep(100);//模拟延迟
                buy();//买票
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    //synchronized同步方法，锁的是this
    private synchronized void buy() {
        if (ticketNums <= 0) {//判断是否有票
            flag = false;
            return;
        }
        System.out.println(Thread.currentThread().getName() + "买到了第" + ticketNums-- + "张票");
    }
}
```

`synchronized` 解决了车票余量错乱、以及余量可能相同的问题。使用 `synchronized` 的方法意味着满足了两个线程安全的特性：

1. **原子性**：方法全部执行并且执行的过程不会被任何因素打断。
2. **可见性**：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

但是 `synchronized` 为了实现这两个特性，也是要付出代价是的：性能可能不高。因为方法加锁，同时只有一个线程竞争成功能继续执行，其它很多线程是持续等待、响应慢的。所以 `synchronized` 不能滥用，比较适合的场景是：

1. 写操作的场景。例如用户修改个人信息、点赞、收藏、下单等。
2. 尽量精确锁住最小的代码块，把最关键的写操作抽象成独立的方法加锁。不建议给大段的方法加锁。

---

**同步块**

- 同步块:synchronized (Obj ){ }
- Obj称之为同步监视器
  - obj可以是任何对象,但是推荐使用共享资源作为同步监视器
  - 同步方法中无需指定同步监视器﹐因为同步方法的同步监视器就是this ,就是这个对象本身，或者是class[反射中讲解]
- 同步监视器的执行过程
  1．第一个线程访问，锁定同步监视器﹐执行其中代码．
  2．第二个线程访问，发现同步监视器被锁定﹐无法访问．
  3．第一个线程访问完毕,解锁同步监视器.

```java
//不安全的买票案例修改
public class Demo17 {
    public static void main(String[] args) {
        BuyTicket buyTicket = new BuyTicket();
        new Thread(buyTicket, "眉笔的我").start();
        new Thread(buyTicket, "欧皇的你").start();
        new Thread(buyTicket, "可恶的黄牛党").start();
    }
}

class BuyTicket implements Runnable {
    private int ticketNums = 10;//票数
    Object obj = new Object(); //同步监视器

    @Override
    public void run() {
        while (true) {
            synchronized (obj) {
                if (ticketNums <= 0) {//判断是否有票
                    break;
                }
                System.out.println(Thread.currentThread().getName() + "买到了第" + ticketNums-- + "张票");
            }

            try {
                Thread.sleep(100);//模拟延迟
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

> 如果是 static 静态方法，则不能直接使用this ，要锁类本身，即xxx.Class

```java
 //synchronized同步静态方法
private static void buy() {
synchronized (BuyTicket.Class) { //锁类本身
    if (ticketNums <= 0) {//判断是否有票
        break;
        }
    }
```









## 6.3 同步锁 Lock

**synchronized 与Lock的对比**

- Lock是显式锁（手动开启和关闭锁，别忘记关闭锁) synchronized是隐式锁，出了作用域自动释放
- Lock只有代码块锁,synchronized有代码块锁和方法锁
- 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类)
- 优先使用顺序:Lock >同步代码块（已经进入了方法体，分配了相应资源)>同步方法（在方法体之外)

---

```java
public class Demo21 {
    public static void main(String[] args) {
        TestLock testLock = new TestLock();
        new Thread(testLock,"线程1").start();
        new Thread(testLock,"线程2").start();
        new Thread(testLock,"线程3").start();
    }
}
class TestLock implements Runnable{
    int ticketNum=10;
    //定义lock锁
    private final ReentrantLock lock =new ReentrantLock();
    @Override
    public void run() {
        while (true){
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            lock.lock();//加锁
            if (ticketNum>0){
                System.out.println(Thread.currentThread().getName()+"获得了第"+ticketNum--+"张票");
            }else {
                lock.unlock();//解锁
                break;
            }
            lock.unlock();//解锁
        }
    }
}
```











## 6.4乐观锁

`java.util.concurrent` 是 Java 系统提供的并发编程包，尝试使用 `java.util.concurrent.atomic.AtomicInteger` 让车票余量能够安全的递减。

```java
public class Ticket {
    private AtomicInteger count = new AtomicInteger(30);

    public void sell() {
        int newCount = 0;
        if (count.get() > 0) {
            newCount = count.decrementAndGet();
        }
        System.out.println(Thread.currentThread().getName() + "：还剩下 " + newCount + " 张票");
    }

    public int getCount() {
        return count.get();
    }
}
```

**解决的问题：**

- sell（）不再加锁，解决了车票余量重复的问题

> `AtomicInteger` 虽然是一个类，但等同于一个整数（就像 Integer 是 int 的对象）。
>
> 调用 `new AtomicInteger()` 构造函数实例化   对象的时候，可以指定任意的整数值。
>
> 不同的是，`AtomicInteger` 提供了不使用 `synchronized` 就能保证数据操作原子性的方法。例如 `decrementAndGet()`方法是     
>
> 三个操作的组合（取得当前值-->减一 --->return新值），多线程情况下也不会出现数值重复的错误，证明这三个操作是密不可分
>
> 的、线程间没有互相干扰打断，保证了数据的正确性。这就是类名 *Atomic* － **原子性**的含义。
>
> 线程间都是基于**最新的**结果进行减一的运算，所以不会重复，这样是 **可见性** 的体现。
>
> `count.decrementAndGet()` 代替了使用 `synchronized` 时，整数 `count--`

**没有解决的问题：**

- 仍然会出现负数车票
- Console打印的顺序也可能错误。

> 这是因为条件判断语句、操作语句、打印信息语句组合起来，就不具备原子性了，因为 `sell()`    不加锁，多条语句执行时就可能被其它线程打断了。所以必须给 `sell()` 整体加 `synchronized` 才能保证多条语句整体的原子性：
>
> public synchronized void sell() {}

---

**注意：**

```java
private static AtomicInteger count = new AtomicInteger(10);

//（取得当前值-->减一 --->return新值）   代替了使用 `synchronized` 时，整数 `count--`
count.decrementAndGet();

//（取得当前值-->加一 --->return新值）   代替了使用 `synchronized` 时，整数 `count++`
count.incrementAndGet();
```



---







## 6.5死锁

多个线程各自占有一些共享资源﹐并且互相等待其他线程占有的资源才能运行﹐而导致两个或者多个线程都在等待对方释放资源﹐都停止执行的情形﹒某一个同步块同时拥有“**两个以上对象的锁**”时﹐就可能会发生“死锁”的问题．

产生死锁的四个必要条件:

- 互斥条件:一个资源每次只能被一个进程使用。
- 请求与保持条件:一个进程因请求资源而阻塞时，对已获得的资源保持不放
- 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
- 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

---

**死锁案例**

```java
public class Demo20 {
    public static void main(String[] args) {
        Makeup girl1 =new Makeup(0,"灰姑娘");
        Makeup girl2 =new Makeup(1,"白雪公主");
        girl1.start();
        girl2.start();
    }
}

class Lipstick{
}
class Mirror{
}

class  Makeup extends Thread{
    //需要的资源只有一份，用static来保证只有一份
    static Lipstick lipstick =new Lipstick();
    static Mirror mirror = new Mirror();
    int choice;//选择
    String girlName;//使用化妆品的女人
    
    Makeup(int choice,String girlName){
        this.choice=choice;
        this.girlName=girlName;
    }
    @Override
    public void run() {
        //化妆
        try {
            makeup();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    private void makeup() throws InterruptedException {//有死锁的makeup方法
        if (choice==0){
            synchronized (lipstick){
                System.out.println(this.girlName+"获得口红的锁");
                Thread.sleep(1000);
                synchronized (mirror){
                    System.out.println(this.girlName+"获得镜子的锁");
                }
            }
        }else {
            synchronized (mirror){
                System.out.println(this.girlName+"获得镜子的锁");
                Thread.sleep(2000);
                synchronized (lipstick){
                    System.out.println(this.girlName+"获得口红的锁");
                }
            }
        }
    }
    
    /*private void makeup() throws InterruptedException {//无死锁的makeup方法
        if (choice == 0) {
            synchronized (lipstick) {
                System.out.println(this.girlName + "获得口红的锁");
                Thread.sleep(1000);
            }
            synchronized (mirror) {
                System.out.println(this.girlName + "获得镜子的锁");
            }
        } else {
            synchronized (mirror) {
                System.out.println(this.girlName + "获得镜子的锁");
                Thread.sleep(2000);
            }
            synchronized (lipstick) {
                System.out.println(this.girlName + "获得口红的锁");
            }
        }
    }*/
}
```





---











# 7.三大特性

- 可见性：当一个线程修改了某些线程共享变量的值，其他线程能够立即得知这个修改。
- 有序性：保证指令不会受cpu指令并行优化的影响(即程序执行的顺序按照代码的先后顺序执行)。
- 原子性：一个操作或者一系列操作，要么全部执行成功，要么全部执行失败。

---



## 7.1可见性 Volatile 

**Volatile 刷新主内存过程**

![image-20230513094831202](https://typora-picgo-push.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20230513094831202.png)

**实例**

```java
public class Demo4 extends Thread{
    volatile int i = 0;
        @Override
        public void run() {
            i = 100;
            System.out.println(i);
        }


    public static void main(String[] args) {
        Demo4 demo4 = new Demo4();
        demo4.start();
        int j=1;
        while(demo4.i==0){
            System.out.println("执行了"+(j++) +"次，未改变初始值"+ demo4.i);
        }
        System.out.println("主线程执行完毕");
    }
}
```

根据执行结果得出结论：添加了volatile关键字更快修改i的值



## 7.2有序性 Volatile

有序性-happens-before原则：(8条)

- 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作系统先行发生于书写在后面的操作；
- 锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作；
- volatile变量规则：对一个变量的写操作先行于发生于后面对这个变量的读操作；



**指令重排案例**

1. 定义static int a、b、x、y;变量，初始化都为0
2. main中一直循环
3. 开启两个线程：第一个线程a=1；x=b； 第二个线程b=1；y=a；
4. 启动两个线程，并使用join
5. 增加volatile观察结果

```java

```



## 7.3 原子性 atomic

```

```









# 8.并发容器

**并发**：在方法调用的时候（就是所谓任务），需要等待返回取得返回值是同步，不等待而继续执行程序代码就是异步。采用异步方式，能够支持多个任务并行执行，这种机制称为并发

- **CompletableFuture**是一个异步任务编排、调度框架，以更优雅的方式实现组合式异步编程。
- 基本的多线程编程不利于任务的管理（包括编排、调度等），在 Java8 时代，使用新的 CompletableFuture技术可以让多线程并发编程更优雅。



## 8.1单步骤

**实例一**：学生注册，在注册同时打印欢迎信息

```java
//学生
public class Student {
    private int id;
    privaet String name;
    //get、set
}
```

```java
//注册
public class Register {
    private static AtomicInteger count = new AtomicInteger(0);//保证id唯一
     // 注册学号
	public Student regId(Student student) {
    	student.setId(count.incrementAndGet());
    	return student;
 	 }  
}
```

```java
//并行注册
public class StudentIDTest {
  public static void main(String[] args) {
    // 构建学生集合
    List<Student> studentList = new ArrayList<>();
    for (int i = 1; i <= 10; i++) {
      Student s = new Student();
      s.setName("学生" + i);
      studentList.add(s);
    }

    Register reg = new Register();

    studentList.forEach(s -> {
      CompletableFuture.supplyAsync(
          // 每个学生都注册学号
          () -> reg.regId(s)
        )
        // 学号注册完毕后，打印欢迎消息
        .thenAccept(student -> {
          System.out.println("你好 " + student.getName() + ", 欢迎来到春蕾中学大家庭");
        });
    });

    System.out.println("mission complate");
  }
}
```

- `CompletableFuture.supplyAsync()` 方法运行一个异步任务并且返回结果，所以 `regId()` 方法必须有返回值。

- `Register` 虽然没有实现 `Runnable` 接口，但系统会自动优化：把作为 `supplyAsync()` 方法参数的整个 `() -> reg.regId(s)` 表达式语句包装在另一个对象中；这个对象是 JDK 内置的，它实现了 `Runnable` 接口，在这个对象中执行表达式语句。所以实际上，`supplyAsync()` 方法的作用是：在一个单独的线程中执行 `reg.regId(s)` 语句，本质上就是多线程编程。
- 在注册完毕以后，使用 `thenAccept()` 方法完成后继的任务步骤。`thenAccept()` 方法的参数（`student`）就是前置任务的返回结果，系统会在前一个任务完成后，**自动**执行 `student -> {}` 后继任务。所以本质上，后继任务也是多线程方式执行的。`thenAccept()` 方法通常用于任务链的末尾。

> 一般情况下，不建议一个大任务的所有步骤都集中在 `supplyAsync()` 里实现，分步骤更好

---



## 8.2 多步骤

**实列二：多步骤任务(部分并发执行代码)**

```java
//并行注册
public class StudentIDTest {
  public static void main(String[] args) {

     //注册类
    Register reg = new Register();

    studentList.forEach(s -> {
      CompletableFuture.supplyAsync(
          // 每个学生都注册学号
          () -> reg.regId(s)
          //审核学生
        ).thenApply(stu -> {
                reg.examine(stu);
                return offer;
        // 学号注册完毕后，打印欢迎消息
       }).thenAccept(student -> {
          System.out.println("你好 " + student.getName() + ", 欢迎来到春蕾中学大家庭");
        });
    });

    System.out.println("mission complate");
  }
}
```

- 只需要调用 `CompletableFuture` 类的 `thenApply()` 方法即可。
- `supplyAsync()` 用于**开头**，`thenAccept()` 用于**末尾**，各自调用一次即可。中间有多个步骤，可以调用多次 `thenApply()` 。
- 由于末尾也要用到 `student` 实例对象，所以位于中间的 `thenApply()` 方法，总是要 `return`

![j5-5-7-1.svg](https://typora-picgo-push.oss-cn-hangzhou.aliyuncs.com/img-for-typora/j5-5-7-1.svg)

对于多个任务之间是并行的，使用多线程同时执行多个任务；

对于一个任务的多个步骤，是串行的，必须执行完前一个步骤才能执行下一个；

---



## 8.3返回值及返回类型

`supplyAsync()` 是静态方法，返回值是 `CompletableFuture` 实例对象，再调用 `thenApply()` 或 `thenAccept()` 实例方法，返回的也是 `CompletableFuture` 实例对象。

```java
CompletableFuture<Void> cf = CompletableFuture.supplyAsync(() -> reg.regId(s))
  .thenApply(student -> {
    return dis.assignClasses(student);
  })
  .thenAccept(student -> {
     System.out.println("姓名：" + student.getName() + "，学号：" + student.getId() + "，班级号：" + student.getClassId());
  });
```

返回的是仍是 `CompletableFuture` 实例对象，所以定义变量的类型就是 `CompletableFuture` 。

但可以用泛型 `CompletableFuture<>` 表示其中包含的数据具体是什么类型。

因为本案例末尾调用了 `thenAccept()`，其 *Lambda* 表达式没有 `return` 语句，表示 `CompletableFuture` 实例对象***不包含***数据，所以泛型写为 `CompletableFuture<Void>`。

---

**返回 CompletableFuture 类型**

如果没有调用 `thenAccept()` 方法，以 `thenApply()` 或 `supplyAsync()` 结尾的话，例如代码：

```java
CompletableFuture<Student> cf = CompletableFuture.supplyAsync(() -> reg.regId(s))
  .thenApply(student -> {
    return dis.assignClasses(student);
  });
```

因为 `thenApply()` 的 *Lambda* 表达式返回的是 `Student` 对象，所以 `CompletableFuture` 实例对象包含的是 `Student` 数据，于是泛型写为 `CompletableFuture<Student>`

> 这几个方法返回的是 `CompletableFuture` 实例，但其中包含什么类型的数据取决于 *Lambda* 表达式返回值的类型，如果没有返回值，则用 `<Void>` 表示。







## 8.4扩展知识点：main() 方法的问题

目前我们的程序，都是通过 `main()` 方法执行的。如果学生人数较多，例如 *2000* 个，所有注册线程的运行就没有那么快完毕了。

问题是，可能线程任务还没执行完毕，`main()` 方法就执行完毕，导致程序运行结束退出了。

要解决这个问题，返回值就有用了。我们先把每个学生的入学任务实例对象（`CompletableFuture<Void>`），收集起来（装入集合），然后等待所有的线程执行完毕。

```java
List<CompletableFuture> cfs = new ArrayList<>();
studentList.forEach(s -> {
  CompletableFuture<Void> cf = CompletableFuture.supplyAsync(() -> reg.regId(s))
    .thenApply(student -> {
        return dis.assignClasses(student);
    }).thenAccept(student -> {
        System.out.println("姓名：" + student.getName() + "，学号：" + student.getId() + "，班级号：" + student.getClassId());
    });

  cfs.add(cf);
});

try {
  // 等待所有的线程执行完毕
  CompletableFuture.allOf(cfs.toArray(new CompletableFuture[] {})).get();
} catch (Exception e) {
  e.printStackTrace();
}
```

`CompletableFuture.allOf()` 是静态方法，作用就是收集所有的任务实例对象。因为 `allOf()` 方法只支持数组不支持集合，所以需要把集合转换成数组（`cfs.toArray(new CompletableFuture[] {})`）。当然，你可以一开始就定义数组来收集任务实例对象，因为学生的个数可以通过 `studentList.size()` 取得。`allOf()` 方法的返回值也是 `CompletableFuture` 实例对象。再调用类方法 `get()`，其作用就是等待所有的任务线程（`allOf()` 收集的）都执行完毕，再继续执行。

**需要强调的是**：

- 在 *SpringBoot* 等服务端运行 `supplyAsync()` 异步任务编排的时候，就没有必要可以使用 `get()` 方法等待所有线程任务执行完毕了。因为服务端往往是常驻程序，不像 `main()` 方法执行完毕就退出程序了。
- `get()` 方法造成了 `main()` 方法等待，所以是同步的；通过 `CompletableFuture` 编排的任务，不会造成 `main()`方法等待，所以是异步。





## 8.5拓展知识点：原子操作布尔值

`java.util.concurrent.atomic.AtomicInteger` 能够以原子的方式操作整数

 `java.util.concurrent.atomic.AtomicBoolean` 能够以原子的方式操作布尔值。

布尔值只有 **true**/**false** 两个值，`AtomicBoolean` 使用起来就很简便了。

`AtomicBoolean` 是 `boolean` 的包装类，`AtomicBoolean` 的实例等同于一个布尔值：

- `new AtomicBoolean(true)` 等同于 **true**
- `new AtomicBoolean(false)` 等同于 **false**

---

**实例对象取得基础类型的布尔值，可以调用 `get()` 方法：**

```java
AtomicBoolean ab = new AtomicBoolean(true);
boolean value = ab.get();
```

**实例对象调用 `compareAndSet()` 方法，就能以原子的方式修改值：**

`compareAndSet(true, false)` 判断当前值为 **true** 时，修改为 **false**，然后返回成功或失败。这是三个步骤哦。

- 修改成功后，方法返回 `true` 。
- 如果当前值不是 **true** ，则不修改，返回值为 `false`，表示操作失败

> `compareAndSet()` 实际上就是保证了整个修改操作的三个步骤的原子性，不会因为多线程出现错乱。

***再次强调***：`compareAndSet()` 方法返回值表示**修改操作**成功或失败，跟方法参数值无关。



**初始化AtomicInteger数组**

```java
private static AtomicBoolean[] PLACES = {
        new AtomicBoolean(float),
        new AtomicBoolean(float)
}; //初始化，存两个float的数组
```





# 9.线程池

使用`Runnable` 接口开发多线程程序，更符合面向对象的习惯，但是随之而来的问题是，对象太多。

在现实中，如果有一千位同学入学，就意味着程序要额外 `new Thread(register)` 一千次。对象除了创建需要消耗计算机 CPU、内存等资源，对象还会被销毁（系统自动做的），销毁也是要消耗资源的。

那么能不能做一些优化，做到复用 `Thread` 对象，不必每次都创建新对象呢？答案是有的：Java 提供了 ***线程池*** 技术。

---

**线程池基本概念**

所谓 线程池，顾名思义，就像一个池子，里面装满了线程，随用随取。线程可以被 复用，一个线程，可以执行 A 任务，也可以执行 B 任务，于是线程不再频繁创建和销毁。

> `new Thread(register)` 意味着一个线程对象只能执行一个任务，而线程池让线程与任务分离，不再紧密绑定。

线程池的另一个重要概念是，线程池并不是无限大的（因为计算机的CPU、内存等资源毕竟有限），所以线程池中存在的线程数也是 **有限** 的，这就意味着能同时运行的任务数是 **有限** 的，其它过剩的任务就需要 **排队** 。待任务完成、有空闲的线程后，才能继续执行任务。

**典型的线程池案例-银行业务办理：**

![image-20230514092841896](https://typora-picgo-push.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20230514092841896.png)

---

## 9.1线程池实现

**通过ThreadPoolExecutor构建线程池服务**

```java
public static void main(String[] args) {
    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
        3,     //创建几个线程 一般两位数
        5,     //线程池最大容量 通常不超过200
        1L,    //多长时间不用自动销毁 想立即回收则0，一般30
        TimeUnit.SECONDS,  //时间单位（这里是秒）
        new ArrayBlockingQueue<>(3),  //等待队列容量[也可以使用自定义的等待队列]
        Executors.defaultThreadFactory(), //线程工厂（通过线程工厂才能创建线程对象）[也可以使用自定义线程工厂]
        new ThreadPoolExecutor.AbortPolicy());  //拒绝策略（当线程池和等待队列都满了，开启拒绝策略，本方法抛出异常）

	//测试
     for (int i = 0; i < 7; i++) {         
         threadPoolExecutor.execute(()->{    
             System.out.println(Thread.currentThread().getName()+"====>正在办理业务");  
             });
        }
}
```

**创建自定义线程工厂**

- `BasicThreadFactory` 需要依赖一个库，这个库也是经常会使用的工具库：

```xml
<dependency>
  <groupId>org.apache.commons</groupId>
  <artifactId>commons-lang3</artifactId>
  <version>3.10</version>
</dependency>
```

- 自定义线程工厂

```java
  private static final ThreadFactory namedThreadFactory = new BasicThreadFactory.Builder()
    .namingPattern("studentReg-pool-%d") //定义线程名字的格式，相当于线程模板，根据需求修改“studentReg”，%d自动编号
    .daemon(true)   //设置线程为守护线程，即后台线程，当所有非守护线程都执行完毕时，JVM会自动退出
    .build();       //构建ThreadFactory对象
```

**创建等待队列**

```java
private static final BlockingQueue<Runnable> workQueue = new LinkedBlockingQueue<Runnable>(1024);
//CPU核多内存大一般2048，性能一般则1024
```

---

**使用线程池运行任务**

```java
 List<Offer> offers = getOffers();
offers.forEach(offer->{
    //创建Runnable 对象
    Publisher publisher=new Publisher(offer);
    // 传入 Runnable 对象，运行任务
    threadPoolExecutor.execute(publisher);
    });
}
```







## 9.2线程池与并发容器的选择

**问题：**多线程编程到底要用什么？并发容器？还是线程池？



实际上 `CompletableFuture` 内部也用到了线程池，是把任务放入内部的**默认线程池**里执行的。

```java
CompletableFuture.supplyAsync(
    () -> reg.regId(s)
  )
```

也可以指定线程池来运行任务：

```java
CompletableFuture.supplyAsync(
    () -> reg.regId(s),
    EXECUTOR_SERVICE //supplyAsync的第二个参数，传入我们构建好的线程池对象。那么任务就是用指定的线程池而不是默认的
  )
```



> ### 技术升级
>
> 线程池也可以运行任务，但是不利于编排，只是把实现了 `Runnable` 接口的任务对象扔进线程池运行。
>
> *Java* 系统的升级进化历程：
>
> ```
> 基础多线程
> ↓
> 线程池
> ↓
> 并发容器
> ```
>
> 如果一家企业技术升级较慢，还处于 **Java 6** 时代，那么多线程编程用***线程池***就够了；如果一家企业技术升级较快，已经使用 **Java 8** ，那就要用并发容器了。
>
> ### 指定线程池的场景
>
> 在学习阶段，一般来说，直接使用 `supplyAsync(() -> {})` 就够了。在企业中，遇到任务并发度高、任务量大、任务执行慢的情况下，就需要指定线程池，严格控制线程任务了。
>
> 或者一开始使用 `CompletableFuture`默认线程池，当发现任务执行满、任务堆积的问题时，就要考虑指定线程池，并调整线程池参数。





























